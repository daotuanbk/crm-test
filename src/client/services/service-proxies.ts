/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.6.0 (NJsonSchema v10.0.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class ServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:3000/api";
    }

    /**
     * Register user
     * @param body (optional) 
     * @return successful operation
     */
    registerUser(body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterUser(_response);
        });
    }

    protected processRegisterUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find permissions list of all modules
     * @return successful operation
     */
    findPermissions(): Promise<FindPermissionsResult> {
        let url_ = this.baseUrl + "/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindPermissions(_response);
        });
    }

    protected processFindPermissions(response: Response): Promise<FindPermissionsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindPermissionsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindPermissionsResult>(<any>null);
    }

    /**
     * Check role name exist
     * @param roleName roleName
     * @return successful operation
     */
    checkRoleNameExist(roleName: string): Promise<CheckRoleNameExistResult> {
        let url_ = this.baseUrl + "/roles/check-name-exist/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckRoleNameExist(_response);
        });
    }

    protected processCheckRoleNameExist(response: Response): Promise<CheckRoleNameExistResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CheckRoleNameExistResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckRoleNameExistResult>(<any>null);
    }

    /**
     * get role by name
     * @param roleName roleName
     * @return successful operation
     */
    getRoleByName(roleName: string): Promise<Role> {
        let url_ = this.baseUrl + "/roles/get-by-name/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoleByName(_response);
        });
    }

    protected processGetRoleByName(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(<any>null);
    }

    /**
     * Find all roles
     * @return successful operation
     */
    getAllRoles(): Promise<GetAllRolesResult> {
        let url_ = this.baseUrl + "/roles/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRoles(_response);
        });
    }

    protected processGetAllRoles(response: Response): Promise<GetAllRolesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetAllRolesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAllRolesResult>(<any>null);
    }

    /**
     * Find all salesman
     * @return successful operation
     */
    getAllSalesmanRole(): Promise<GetAllRolesResult> {
        let url_ = this.baseUrl + "/roles/get-salesman";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSalesmanRole(_response);
        });
    }

    protected processGetAllSalesmanRole(response: Response): Promise<GetAllRolesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetAllRolesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAllRolesResult>(<any>null);
    }

    /**
     * Find all salesman
     * @return successful operation
     */
    getAllSalesmanRole2(): Promise<GetAllRolesResult> {
        let url_ = this.baseUrl + "/roles/get-salesman/{centreId}";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSalesmanRole2(_response);
        });
    }

    protected processGetAllSalesmanRole2(response: Response): Promise<GetAllRolesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetAllRolesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAllRolesResult>(<any>null);
    }

    /**
     * Find role by id
     * @param roleId roleId
     * @return successful operation
     */
    findRoleById(roleId: string): Promise<Role> {
        let url_ = this.baseUrl + "/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindRoleById(_response);
        });
    }

    protected processFindRoleById(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(<any>null);
    }

    /**
     * Update role
     * @param roleId roleId
     * @param body (optional) 
     * @return successful operation
     */
    updateRole(roleId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find roles
     * @param search (optional) search
     * @param permissions (optional) filter by permissions
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findRoles(search: string | undefined, permissions: string[] | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindRolesResult> {
        let url_ = this.baseUrl + "/roles?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "permissions=" + encodeURIComponent("" + item) + "&"; });
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindRoles(_response);
        });
    }

    protected processFindRoles(response: Response): Promise<FindRolesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindRolesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindRolesResult>(<any>null);
    }

    /**
     * Create role
     * @param body (optional) 
     * @return successful operation
     */
    createRole(body: any | undefined): Promise<Role> {
        let url_ = this.baseUrl + "/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(<any>null);
    }

    /**
     * Find profile
     * @param userId userId
     * @return successful operation
     */
    findProfile(userId: string): Promise<User> {
        let url_ = this.baseUrl + "/profile/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProfile(_response);
        });
    }

    protected processFindProfile(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Update profile
     * @param userId userId
     * @param body (optional) 
     * @return successful operation
     */
    updateProfile(userId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/profile/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProfile(_response);
        });
    }

    protected processUpdateProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Check lead filter name exist
     * @param filterName filterName
     * @return successful operation
     */
    checkFilterName(filterName: string): Promise<CheckFilterNameResult> {
        let url_ = this.baseUrl + "/lead-filters/customs/check-filter-name/{filterName}";
        if (filterName === undefined || filterName === null)
            throw new Error("The parameter 'filterName' must be defined.");
        url_ = url_.replace("{filterName}", encodeURIComponent("" + filterName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckFilterName(_response);
        });
    }

    protected processCheckFilterName(response: Response): Promise<CheckFilterNameResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CheckFilterNameResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 202) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckFilterNameResult>(<any>null);
    }

    /**
     * Create lead filter
     * @param body (optional) 
     * @return successful operation
     */
    createLeadFilter(body: any | undefined): Promise<LeadFilter> {
        let url_ = this.baseUrl + "/lead-filters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadFilter(_response);
        });
    }

    protected processCreateLeadFilter(response: Response): Promise<LeadFilter> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadFilter>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LeadFilter>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadFilter>(<any>null);
    }

    /**
     * Find lead filter for an account
     * @param operation (optional) operation
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findLeadFilters(operation: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindLeadFiltersResult> {
        let url_ = this.baseUrl + "/lead-filters?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadFilters(_response);
        });
    }

    protected processFindLeadFilters(response: Response): Promise<FindLeadFiltersResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLeadFiltersResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLeadFiltersResult>(<any>null);
    }

    /**
     * Delete lead filter
     * @param leadFilterId leadFilterId
     * @return successful operation
     */
    deleteLeadFilter(leadFilterId: string): Promise<void> {
        let url_ = this.baseUrl + "/lead-filters/{leadFilterId}";
        if (leadFilterId === undefined || leadFilterId === null)
            throw new Error("The parameter 'leadFilterId' must be defined.");
        url_ = url_.replace("{leadFilterId}", encodeURIComponent("" + leadFilterId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLeadFilter(_response);
        });
    }

    protected processDeleteLeadFilter(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find all campaigns
     * @param operation (optional) opearation
     * @param fields (optional) 
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findCampaigns(operation: string | undefined, fields: string | undefined, search: string | undefined, filter: any[] | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindCampaignsResult> {
        let url_ = this.baseUrl + "/campaign?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindCampaigns(_response);
        });
    }

    protected processFindCampaigns(response: Response): Promise<FindCampaignsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindCampaignsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindCampaignsResult>(<any>null);
    }

    /**
     * Create Campaign
     * @param body (optional) 
     * @return successful operation
     */
    createCampaign(body: any | undefined): Promise<Campaign> {
        let url_ = this.baseUrl + "/campaign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCampaign(_response);
        });
    }

    protected processCreateCampaign(response: Response): Promise<Campaign> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Campaign>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Campaign>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Campaign>(<any>null);
    }

    /**
     * Find all email templates
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findEmailTemplates(search: string | undefined, filter: any[] | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindEmailTemplatesResult> {
        let url_ = this.baseUrl + "/email-template?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindEmailTemplates(_response);
        });
    }

    protected processFindEmailTemplates(response: Response): Promise<FindEmailTemplatesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindEmailTemplatesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindEmailTemplatesResult>(<any>null);
    }

    /**
     * Create email template
     * @param body (optional) 
     * @return successful operation
     */
    createEmailTemplate(body: any | undefined): Promise<EmailTemplate> {
        let url_ = this.baseUrl + "/email-template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEmailTemplate(_response);
        });
    }

    protected processCreateEmailTemplate(response: Response): Promise<EmailTemplate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailTemplate>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <EmailTemplate>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmailTemplate>(<any>null);
    }

    /**
     * Find all email templates
     * @return successful operation
     */
    findAllEmailTemplates(): Promise<FindEmailTemplatesResult> {
        let url_ = this.baseUrl + "/email-template/get-all-template";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindAllEmailTemplates(_response);
        });
    }

    protected processFindAllEmailTemplates(response: Response): Promise<FindEmailTemplatesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindEmailTemplatesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindEmailTemplatesResult>(<any>null);
    }

    /**
     * Find email template by id
     * @param emailTemplateId emailTemplateId
     * @return successful operation
     */
    findEmailTemplateById(emailTemplateId: string): Promise<EmailTemplate> {
        let url_ = this.baseUrl + "/email-template/{emailTemplateId}";
        if (emailTemplateId === undefined || emailTemplateId === null)
            throw new Error("The parameter 'emailTemplateId' must be defined.");
        url_ = url_.replace("{emailTemplateId}", encodeURIComponent("" + emailTemplateId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindEmailTemplateById(_response);
        });
    }

    protected processFindEmailTemplateById(response: Response): Promise<EmailTemplate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailTemplate>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmailTemplate>(<any>null);
    }

    /**
     * Update email template
     * @param emailTemplateId emailTemplateId
     * @param body (optional) 
     * @return successful operation
     */
    updateEmailTemplate(emailTemplateId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/email-template/{emailTemplateId}";
        if (emailTemplateId === undefined || emailTemplateId === null)
            throw new Error("The parameter 'emailTemplateId' must be defined.");
        url_ = url_.replace("{emailTemplateId}", encodeURIComponent("" + emailTemplateId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEmailTemplate(_response);
        });
    }

    protected processUpdateEmailTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete email template
     * @param emailTemplateId emailTemplateId
     * @return successful operation
     */
    removeEmailTemplate(emailTemplateId: string): Promise<void> {
        let url_ = this.baseUrl + "/email-template/{emailTemplateId}";
        if (emailTemplateId === undefined || emailTemplateId === null)
            throw new Error("The parameter 'emailTemplateId' must be defined.");
        url_ = url_.replace("{emailTemplateId}", encodeURIComponent("" + emailTemplateId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveEmailTemplate(_response);
        });
    }

    protected processRemoveEmailTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find all email template configs
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findEmailTemplateConfigs(search: string | undefined, filter: any[] | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindEmailTemplateConfigsResult> {
        let url_ = this.baseUrl + "/email-template-config?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindEmailTemplateConfigs(_response);
        });
    }

    protected processFindEmailTemplateConfigs(response: Response): Promise<FindEmailTemplateConfigsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindEmailTemplateConfigsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindEmailTemplateConfigsResult>(<any>null);
    }

    /**
     * Create email template config
     * @param body (optional) 
     * @return successful operation
     */
    createEmailTemplateConfig(body: any | undefined): Promise<EmailTemplateConfig> {
        let url_ = this.baseUrl + "/email-template-config";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEmailTemplateConfig(_response);
        });
    }

    protected processCreateEmailTemplateConfig(response: Response): Promise<EmailTemplateConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailTemplateConfig>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <EmailTemplateConfig>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmailTemplateConfig>(<any>null);
    }

    /**
     * Find email template config by name
     * @param name name
     * @return successful operation
     */
    findEmailTemplateConfigByName(name: string): Promise<FindEmailTemplateConfigByNameResult> {
        let url_ = this.baseUrl + "/email-template-config/get-by-name?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindEmailTemplateConfigByName(_response);
        });
    }

    protected processFindEmailTemplateConfigByName(response: Response): Promise<FindEmailTemplateConfigByNameResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindEmailTemplateConfigByNameResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindEmailTemplateConfigByNameResult>(<any>null);
    }

    /**
     * Find all email template config
     * @return successful operation
     */
    findAllEmailTemplateConfig(): Promise<FindEmailTemplateConfigByNameResult> {
        let url_ = this.baseUrl + "/email-template-config/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindAllEmailTemplateConfig(_response);
        });
    }

    protected processFindAllEmailTemplateConfig(response: Response): Promise<FindEmailTemplateConfigByNameResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindEmailTemplateConfigByNameResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindEmailTemplateConfigByNameResult>(<any>null);
    }

    /**
     * Find email template config by ids
     * @param ids ids
     * @return successful operation
     */
    findEmailTemplateConfigbyIds(ids: string[]): Promise<FindEmailTemplateConfigByNameResult> {
        let url_ = this.baseUrl + "/email-template-config/find-by-ids?";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindEmailTemplateConfigbyIds(_response);
        });
    }

    protected processFindEmailTemplateConfigbyIds(response: Response): Promise<FindEmailTemplateConfigByNameResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindEmailTemplateConfigByNameResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindEmailTemplateConfigByNameResult>(<any>null);
    }

    /**
     * Find email template config by id
     * @param emailTemplateConfigId emailTemplateConfigId
     * @return successful operation
     */
    findEmailTemplateConfigById(emailTemplateConfigId: string): Promise<EmailTemplateConfig> {
        let url_ = this.baseUrl + "/email-template-config/{emailTemplateConfigId}";
        if (emailTemplateConfigId === undefined || emailTemplateConfigId === null)
            throw new Error("The parameter 'emailTemplateConfigId' must be defined.");
        url_ = url_.replace("{emailTemplateConfigId}", encodeURIComponent("" + emailTemplateConfigId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindEmailTemplateConfigById(_response);
        });
    }

    protected processFindEmailTemplateConfigById(response: Response): Promise<EmailTemplateConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailTemplateConfig>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmailTemplateConfig>(<any>null);
    }

    /**
     * Update email template config
     * @param emailTemplateConfigId emailTemplateConfigId
     * @param body (optional) 
     * @return successful operation
     */
    updateEmailTemplateConfig(emailTemplateConfigId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/email-template-config/{emailTemplateConfigId}";
        if (emailTemplateConfigId === undefined || emailTemplateConfigId === null)
            throw new Error("The parameter 'emailTemplateConfigId' must be defined.");
        url_ = url_.replace("{emailTemplateConfigId}", encodeURIComponent("" + emailTemplateConfigId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEmailTemplateConfig(_response);
        });
    }

    protected processUpdateEmailTemplateConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find all default tasks
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findDefaultTasks(search: string | undefined, filter: any[] | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindDefaultTasksResult> {
        let url_ = this.baseUrl + "/default-task?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindDefaultTasks(_response);
        });
    }

    protected processFindDefaultTasks(response: Response): Promise<FindDefaultTasksResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindDefaultTasksResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindDefaultTasksResult>(<any>null);
    }

    /**
     * Create Default Tasks
     * @param body (optional) 
     * @return successful operation
     */
    createDefaultTask(body: any | undefined): Promise<DefaultTask> {
        let url_ = this.baseUrl + "/default-task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDefaultTask(_response);
        });
    }

    protected processCreateDefaultTask(response: Response): Promise<DefaultTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DefaultTask>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <DefaultTask>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DefaultTask>(<any>null);
    }

    /**
     * Find default-tasl by id
     * @param defaultTaskId defaultTaskId
     * @return successful operation
     */
    findDefaultTaskById(defaultTaskId: string): Promise<DefaultTask> {
        let url_ = this.baseUrl + "/default-task/{defaultTaskId}";
        if (defaultTaskId === undefined || defaultTaskId === null)
            throw new Error("The parameter 'defaultTaskId' must be defined.");
        url_ = url_.replace("{defaultTaskId}", encodeURIComponent("" + defaultTaskId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindDefaultTaskById(_response);
        });
    }

    protected processFindDefaultTaskById(response: Response): Promise<DefaultTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DefaultTask>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DefaultTask>(<any>null);
    }

    /**
     * Update Campaign
     * @param defaultTaskId defaultTaskId
     * @param body (optional) 
     * @return successful operation
     */
    updateDefaultTask(defaultTaskId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/default-task/{defaultTaskId}";
        if (defaultTaskId === undefined || defaultTaskId === null)
            throw new Error("The parameter 'defaultTaskId' must be defined.");
        url_ = url_.replace("{defaultTaskId}", encodeURIComponent("" + defaultTaskId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDefaultTask(_response);
        });
    }

    protected processUpdateDefaultTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find campaign by id
     * @param campaignId campaignId
     * @return successful operation
     */
    findCampaignById(campaignId: string): Promise<Campaign> {
        let url_ = this.baseUrl + "/campaign/{campaignId}";
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined.");
        url_ = url_.replace("{campaignId}", encodeURIComponent("" + campaignId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindCampaignById(_response);
        });
    }

    protected processFindCampaignById(response: Response): Promise<Campaign> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Campaign>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Campaign>(<any>null);
    }

    /**
     * Update Campaign
     * @param campaignId campaignId
     * @param body (optional) 
     * @return successful operation
     */
    updateCampaign(campaignId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/campaign/{campaignId}";
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined.");
        url_ = url_.replace("{campaignId}", encodeURIComponent("" + campaignId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCampaign(_response);
        });
    }

    protected processUpdateCampaign(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete campaign
     * @param campaignId campaignId
     * @return successful operation
     */
    removeCampaign(campaignId: string): Promise<void> {
        let url_ = this.baseUrl + "/campaign/{campaignId}";
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined.");
        url_ = url_.replace("{campaignId}", encodeURIComponent("" + campaignId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveCampaign(_response);
        });
    }

    protected processRemoveCampaign(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create Lead Task
     * @param body (optional) 
     * @return successful operation
     */
    createLeadTask(body: any | undefined): Promise<LeadTask> {
        let url_ = this.baseUrl + "/lead-task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadTask(_response);
        });
    }

    protected processCreateLeadTask(response: Response): Promise<LeadTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadTask>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LeadTask>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadTask>(<any>null);
    }

    /**
     * Find lead task by id
     * @param leadTaskId leadTaskId
     * @return successful operation
     */
    findLeadTaskById(leadTaskId: string): Promise<LeadTask> {
        let url_ = this.baseUrl + "/lead-task/{leadTaskId}";
        if (leadTaskId === undefined || leadTaskId === null)
            throw new Error("The parameter 'leadTaskId' must be defined.");
        url_ = url_.replace("{leadTaskId}", encodeURIComponent("" + leadTaskId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadTaskById(_response);
        });
    }

    protected processFindLeadTaskById(response: Response): Promise<LeadTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadTask>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadTask>(<any>null);
    }

    /**
     * Update Lead Task
     * @param leadTaskId leadTaskId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadTask(leadTaskId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/lead-task/{leadTaskId}";
        if (leadTaskId === undefined || leadTaskId === null)
            throw new Error("The parameter 'leadTaskId' must be defined.");
        url_ = url_.replace("{leadTaskId}", encodeURIComponent("" + leadTaskId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadTask(_response);
        });
    }

    protected processUpdateLeadTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete Lead Task
     * @param leadTaskId leadTaskId
     * @return successful operation
     */
    removeLeadTask(leadTaskId: string): Promise<void> {
        let url_ = this.baseUrl + "/lead-task/{leadTaskId}";
        if (leadTaskId === undefined || leadTaskId === null)
            throw new Error("The parameter 'leadTaskId' must be defined.");
        url_ = url_.replace("{leadTaskId}", encodeURIComponent("" + leadTaskId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveLeadTask(_response);
        });
    }

    protected processRemoveLeadTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find lead tasks by leadId
     * @param leadId leadId
     * @return successful operation
     */
    findLeadTasksByLeadId(leadId: string): Promise<FindAllLeadTasksResult> {
        let url_ = this.baseUrl + "/lead-task/get-lead-tasks/{leadId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadTasksByLeadId(_response);
        });
    }

    protected processFindLeadTasksByLeadId(response: Response): Promise<FindAllLeadTasksResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllLeadTasksResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllLeadTasksResult>(<any>null);
    }

    /**
     * Find lead tasks
     * @return successful operation
     */
    findAllLeadTasks(): Promise<FindAllLeadTasksResult> {
        let url_ = this.baseUrl + "/lead-task/get-all-lead-tasks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindAllLeadTasks(_response);
        });
    }

    protected processFindAllLeadTasks(response: Response): Promise<FindAllLeadTasksResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllLeadTasksResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllLeadTasksResult>(<any>null);
    }

    /**
     * Find lead payment transaction
     * @param leadId leadId
     * @return successful operation
     */
    findLeadPaymentTransaction(leadId: string): Promise<FindLeadPaymentTransaction> {
        let url_ = this.baseUrl + "/lead-payment-transaction?";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined and cannot be null.");
        else
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadPaymentTransaction(_response);
        });
    }

    protected processFindLeadPaymentTransaction(response: Response): Promise<FindLeadPaymentTransaction> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLeadPaymentTransaction>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLeadPaymentTransaction>(<any>null);
    }

    /**
     * Create Lead Payment Transaction
     * @param body (optional) 
     * @return successful operation
     */
    createLeadPaymentTransaction(body: any | undefined): Promise<LeadPaymentTransaction> {
        let url_ = this.baseUrl + "/lead-payment-transaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadPaymentTransaction(_response);
        });
    }

    protected processCreateLeadPaymentTransaction(response: Response): Promise<LeadPaymentTransaction> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadPaymentTransaction>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LeadPaymentTransaction>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadPaymentTransaction>(<any>null);
    }

    /**
     * Find lead payment transaction by id
     * @param leadPaymentTransactionId leadPaymentTransactionId
     * @return successful operation
     */
    findLeadPaymentTransactionById(leadPaymentTransactionId: string): Promise<LeadPaymentTransaction> {
        let url_ = this.baseUrl + "/lead-payment-transaction/{leadPaymentTransactionId}";
        if (leadPaymentTransactionId === undefined || leadPaymentTransactionId === null)
            throw new Error("The parameter 'leadPaymentTransactionId' must be defined.");
        url_ = url_.replace("{leadPaymentTransactionId}", encodeURIComponent("" + leadPaymentTransactionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadPaymentTransactionById(_response);
        });
    }

    protected processFindLeadPaymentTransactionById(response: Response): Promise<LeadPaymentTransaction> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadPaymentTransaction>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadPaymentTransaction>(<any>null);
    }

    /**
     * Update Lead Payment Transaction
     * @param leadPaymentTransactionId leadPaymentTransactionId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadPaymentTransaction(leadPaymentTransactionId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/lead-payment-transaction/{leadPaymentTransactionId}";
        if (leadPaymentTransactionId === undefined || leadPaymentTransactionId === null)
            throw new Error("The parameter 'leadPaymentTransactionId' must be defined.");
        url_ = url_.replace("{leadPaymentTransactionId}", encodeURIComponent("" + leadPaymentTransactionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadPaymentTransaction(_response);
        });
    }

    protected processUpdateLeadPaymentTransaction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete lead payment transaction
     * @param leadPaymentTransactionId leadPaymentTransactionId
     * @return successful operation
     */
    deleteLeadPaymentTransaction(leadPaymentTransactionId: string): Promise<void> {
        let url_ = this.baseUrl + "/lead-payment-transaction/{leadPaymentTransactionId}";
        if (leadPaymentTransactionId === undefined || leadPaymentTransactionId === null)
            throw new Error("The parameter 'leadPaymentTransactionId' must be defined.");
        url_ = url_.replace("{leadPaymentTransactionId}", encodeURIComponent("" + leadPaymentTransactionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLeadPaymentTransaction(_response);
        });
    }

    protected processDeleteLeadPaymentTransaction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find lead note
     * @param operation (optional) operation
     * @param fields (optional) 
     * @return successful operation
     */
    findLeadNote(operation: string | undefined, fields: string | undefined): Promise<FindLeadNote> {
        let url_ = this.baseUrl + "/lead-note?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadNote(_response);
        });
    }

    protected processFindLeadNote(response: Response): Promise<FindLeadNote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLeadNote>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLeadNote>(<any>null);
    }

    /**
     * Create Lead Note
     * @param body (optional) 
     * @return successful operation
     */
    createLeadNote(body: any | undefined): Promise<LeadNote> {
        let url_ = this.baseUrl + "/lead-note";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadNote(_response);
        });
    }

    protected processCreateLeadNote(response: Response): Promise<LeadNote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadNote>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LeadNote>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadNote>(<any>null);
    }

    /**
     * Find lead note by id
     * @param leadNoteId leadNoteId
     * @return successful operation
     */
    findLeadNoteById(leadNoteId: string): Promise<LeadNote> {
        let url_ = this.baseUrl + "/lead-note/{leadNoteId}";
        if (leadNoteId === undefined || leadNoteId === null)
            throw new Error("The parameter 'leadNoteId' must be defined.");
        url_ = url_.replace("{leadNoteId}", encodeURIComponent("" + leadNoteId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadNoteById(_response);
        });
    }

    protected processFindLeadNoteById(response: Response): Promise<LeadNote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadNote>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadNote>(<any>null);
    }

    /**
     * Update Lead Note
     * @param leadNoteId leadNoteId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadNote(leadNoteId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/lead-note/{leadNoteId}";
        if (leadNoteId === undefined || leadNoteId === null)
            throw new Error("The parameter 'leadNoteId' must be defined.");
        url_ = url_.replace("{leadNoteId}", encodeURIComponent("" + leadNoteId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadNote(_response);
        });
    }

    protected processUpdateLeadNote(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find prospecting-list
     * @param operation (optional) 
     * @param fields (optional) 
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findProspectingLists(operation: string | undefined, fields: any[] | undefined, search: string | undefined, filter: string | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindAllProspectingListsResult> {
        let url_ = this.baseUrl + "/prospecting-list?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProspectingLists(_response);
        });
    }

    protected processFindProspectingLists(response: Response): Promise<FindAllProspectingListsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllProspectingListsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllProspectingListsResult>(<any>null);
    }

    /**
     * Create prospecting-list
     * @param body (optional) 
     * @return successful operation
     */
    createProspectingList(body: any | undefined): Promise<ProspectingList> {
        let url_ = this.baseUrl + "/prospecting-list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProspectingList(_response);
        });
    }

    protected processCreateProspectingList(response: Response): Promise<ProspectingList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProspectingList>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <ProspectingList>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProspectingList>(<any>null);
    }

    /**
     * Find prospecting-list by id
     * @param prospectingListId prospectingListId
     * @return successful operation
     */
    findProspectingListById(prospectingListId: string): Promise<ProspectingList> {
        let url_ = this.baseUrl + "/prospecting-list/{prospectingListId}";
        if (prospectingListId === undefined || prospectingListId === null)
            throw new Error("The parameter 'prospectingListId' must be defined.");
        url_ = url_.replace("{prospectingListId}", encodeURIComponent("" + prospectingListId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProspectingListById(_response);
        });
    }

    protected processFindProspectingListById(response: Response): Promise<ProspectingList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProspectingList>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProspectingList>(<any>null);
    }

    /**
     * Update prospecting-list
     * @param prospectingListId prospectingListId
     * @param body (optional) 
     * @return successful operation
     */
    updateProspectingList(prospectingListId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/prospecting-list/{prospectingListId}";
        if (prospectingListId === undefined || prospectingListId === null)
            throw new Error("The parameter 'prospectingListId' must be defined.");
        url_ = url_.replace("{prospectingListId}", encodeURIComponent("" + prospectingListId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProspectingList(_response);
        });
    }

    protected processUpdateProspectingList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete prospecting-list
     * @param prospectingListId prospectingListId
     * @return successful operation
     */
    removeProspectingList(prospectingListId: string): Promise<void> {
        let url_ = this.baseUrl + "/prospecting-list/{prospectingListId}";
        if (prospectingListId === undefined || prospectingListId === null)
            throw new Error("The parameter 'prospectingListId' must be defined.");
        url_ = url_.replace("{prospectingListId}", encodeURIComponent("" + prospectingListId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveProspectingList(_response);
        });
    }

    protected processRemoveProspectingList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find lead appointments
     * @param fields (optional) 
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findLeadAppointments(operation: string, fields: any | undefined, search: string | undefined, filter: any[] | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindAllLeadAppointmentsResult> {
        let url_ = this.baseUrl + "/lead-appointment?";
        if (operation === undefined || operation === null)
            throw new Error("The parameter 'operation' must be defined and cannot be null.");
        else
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadAppointments(_response);
        });
    }

    protected processFindLeadAppointments(response: Response): Promise<FindAllLeadAppointmentsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllLeadAppointmentsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllLeadAppointmentsResult>(<any>null);
    }

    /**
     * Create Lead Appointment
     * @param body (optional) 
     * @return successful operation
     */
    createLeadAppointment(body: any | undefined): Promise<LeadAppointment> {
        let url_ = this.baseUrl + "/lead-appointment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadAppointment(_response);
        });
    }

    protected processCreateLeadAppointment(response: Response): Promise<LeadAppointment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadAppointment>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LeadAppointment>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadAppointment>(<any>null);
    }

    /**
     * Find lead appointment by id
     * @param leadAppointmentId leadAppointmentId
     * @return successful operation
     */
    findLeadAppointmentById(leadAppointmentId: string): Promise<LeadAppointment> {
        let url_ = this.baseUrl + "/lead-appointment/{leadAppointmentId}";
        if (leadAppointmentId === undefined || leadAppointmentId === null)
            throw new Error("The parameter 'leadAppointmentId' must be defined.");
        url_ = url_.replace("{leadAppointmentId}", encodeURIComponent("" + leadAppointmentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadAppointmentById(_response);
        });
    }

    protected processFindLeadAppointmentById(response: Response): Promise<LeadAppointment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadAppointment>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadAppointment>(<any>null);
    }

    /**
     * Update Lead Appointment
     * @param leadAppointmentId leadAppointmentId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadAppointment(leadAppointmentId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/lead-appointment/{leadAppointmentId}";
        if (leadAppointmentId === undefined || leadAppointmentId === null)
            throw new Error("The parameter 'leadAppointmentId' must be defined.");
        url_ = url_.replace("{leadAppointmentId}", encodeURIComponent("" + leadAppointmentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadAppointment(_response);
        });
    }

    protected processUpdateLeadAppointment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete Lead Appointment
     * @param leadAppointmentId leadAppointmentId
     * @return successful operation
     */
    removeLeadAppointment(leadAppointmentId: string): Promise<void> {
        let url_ = this.baseUrl + "/lead-appointment/{leadAppointmentId}";
        if (leadAppointmentId === undefined || leadAppointmentId === null)
            throw new Error("The parameter 'leadAppointmentId' must be defined.");
        url_ = url_.replace("{leadAppointmentId}", encodeURIComponent("" + leadAppointmentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveLeadAppointment(_response);
        });
    }

    protected processRemoveLeadAppointment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find lead appointments by leadId
     * @param leadId leadId
     * @return successful operation
     */
    findLeadAppointmentsByLeadId(leadId: string): Promise<FindAllLeadAppointmentsResult> {
        let url_ = this.baseUrl + "/lead-appointment/get-lead-appointments/{leadId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadAppointmentsByLeadId(_response);
        });
    }

    protected processFindLeadAppointmentsByLeadId(response: Response): Promise<FindAllLeadAppointmentsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllLeadAppointmentsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllLeadAppointmentsResult>(<any>null);
    }

    /**
     * Find lead appointments
     * @return successful operation
     */
    findAllLeadAppointments(): Promise<FindAllLeadAppointmentsResult> {
        let url_ = this.baseUrl + "/lead-appointment/get-all-lead-appointments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindAllLeadAppointments(_response);
        });
    }

    protected processFindAllLeadAppointments(response: Response): Promise<FindAllLeadAppointmentsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllLeadAppointmentsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllLeadAppointmentsResult>(<any>null);
    }

    /**
     * Find Lead Conversations
     * @param operation (optional) operation
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findLeadConversations(operation: string | undefined, search: string | undefined, filter: string | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindLeadConversationsResult> {
        let url_ = this.baseUrl + "/lead-conversation?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadConversations(_response);
        });
    }

    protected processFindLeadConversations(response: Response): Promise<FindLeadConversationsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLeadConversationsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLeadConversationsResult>(<any>null);
    }

    /**
     * Find Lead Notifications
     * @param operation (optional) operation
     * @param fields (optional) 
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findLeadNotifications(operation: string | undefined, fields: string | undefined, search: string | undefined, filter: string | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindLeadNotificationsResult> {
        let url_ = this.baseUrl + "/lead-notification?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadNotifications(_response);
        });
    }

    protected processFindLeadNotifications(response: Response): Promise<FindLeadNotificationsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLeadNotificationsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLeadNotificationsResult>(<any>null);
    }

    /**
     * Update lead notification
     * @param leadNotificationId leadNotificationId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadNotification(leadNotificationId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/lead-notification/{leadNotificationId}";
        if (leadNotificationId === undefined || leadNotificationId === null)
            throw new Error("The parameter 'leadNotificationId' must be defined.");
        url_ = url_.replace("{leadNotificationId}", encodeURIComponent("" + leadNotificationId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadNotification(_response);
        });
    }

    protected processUpdateLeadNotification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find Lead Attachment
     * @param operation (optional) operation
     * @param fields (optional) 
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findLeadAttachments(operation: string | undefined, fields: string | undefined, search: string | undefined, filter: string | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindLeadAttachmentsResult> {
        let url_ = this.baseUrl + "/lead-attachment?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadAttachments(_response);
        });
    }

    protected processFindLeadAttachments(response: Response): Promise<FindLeadAttachmentsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLeadAttachmentsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLeadAttachmentsResult>(<any>null);
    }

    /**
     * Create lead attachment
     * @param body (optional) 
     * @return successful operation
     */
    createLeadAttachment(body: any | undefined): Promise<LeadAttachment> {
        let url_ = this.baseUrl + "/lead-attachment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadAttachment(_response);
        });
    }

    protected processCreateLeadAttachment(response: Response): Promise<LeadAttachment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadAttachment>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LeadAttachment>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadAttachment>(<any>null);
    }

    /**
     * Find lead attachment by id
     * @param leadAttachmentId leadAttachmentId
     * @return successful operation
     */
    findLeadAttachmentById(leadAttachmentId: string): Promise<LeadAttachment> {
        let url_ = this.baseUrl + "/lead-attachment/{leadAttachmentId}";
        if (leadAttachmentId === undefined || leadAttachmentId === null)
            throw new Error("The parameter 'leadAttachmentId' must be defined.");
        url_ = url_.replace("{leadAttachmentId}", encodeURIComponent("" + leadAttachmentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadAttachmentById(_response);
        });
    }

    protected processFindLeadAttachmentById(response: Response): Promise<LeadAttachment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadAttachment>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadAttachment>(<any>null);
    }

    /**
     * Find Lead Message Details
     * @param operation (optional) operation
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findLeadMessageDetails(operation: string | undefined, search: string | undefined, filter: string | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindLeadMessageDetailsResult> {
        let url_ = this.baseUrl + "/lead-message-detail?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadMessageDetails(_response);
        });
    }

    protected processFindLeadMessageDetails(response: Response): Promise<FindLeadMessageDetailsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLeadMessageDetailsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLeadMessageDetailsResult>(<any>null);
    }

    /**
     * sync email message
     * @param body (optional) 
     * @return successful operation
     */
    syncEmailMessage(body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/lead-message-detail/sync-email-message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSyncEmailMessage(_response);
        });
    }

    protected processSyncEmailMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find systemconfigs
     * @param operation (optional) operation
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findSystemConfigs(operation: string | undefined, search: string | undefined, filter: any[] | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindSystemConfigsResult> {
        let url_ = this.baseUrl + "/system-config?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindSystemConfigs(_response);
        });
    }

    protected processFindSystemConfigs(response: Response): Promise<FindSystemConfigsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindSystemConfigsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindSystemConfigsResult>(<any>null);
    }

    /**
     * Create System Configs
     * @param body (optional) 
     * @return successful operation
     */
    createSystemConfig(body: any | undefined): Promise<SystemConfig> {
        let url_ = this.baseUrl + "/system-config";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSystemConfig(_response);
        });
    }

    protected processCreateSystemConfig(response: Response): Promise<SystemConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SystemConfig>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <SystemConfig>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SystemConfig>(<any>null);
    }

    /**
     * Find config by id
     * @param systemConfigId systemconfigId
     * @return successful operation
     */
    findSystemConfigById(systemConfigId: string): Promise<SystemConfig> {
        let url_ = this.baseUrl + "/system-config/{systemConfigId}";
        if (systemConfigId === undefined || systemConfigId === null)
            throw new Error("The parameter 'systemConfigId' must be defined.");
        url_ = url_.replace("{systemConfigId}", encodeURIComponent("" + systemConfigId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindSystemConfigById(_response);
        });
    }

    protected processFindSystemConfigById(response: Response): Promise<SystemConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SystemConfig>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SystemConfig>(<any>null);
    }

    /**
     * Update system config
     * @param systemConfigId systemConfigId
     * @param body (optional) 
     * @return successful operation
     */
    updateSystemConfig(systemConfigId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/system-config/{systemConfigId}";
        if (systemConfigId === undefined || systemConfigId === null)
            throw new Error("The parameter 'systemConfigId' must be defined.");
        url_ = url_.replace("{systemConfigId}", encodeURIComponent("" + systemConfigId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSystemConfig(_response);
        });
    }

    protected processUpdateSystemConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find all stages
     * @return successful operation
     */
    findLeadStages(): Promise<FindSomeSystemConfigsResult> {
        let url_ = this.baseUrl + "/system-config/lead-stage/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadStages(_response);
        });
    }

    protected processFindLeadStages(response: Response): Promise<FindSomeSystemConfigsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindSomeSystemConfigsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindSomeSystemConfigsResult>(<any>null);
    }

    /**
     * Find all class stages
     * @return successful operation
     */
    findLeadStages2(): Promise<FindSomeSystemConfigsResult> {
        let url_ = this.baseUrl + "/system-config/lead-class-stage/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadStages2(_response);
        });
    }

    protected processFindLeadStages2(response: Response): Promise<FindSomeSystemConfigsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindSomeSystemConfigsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindSomeSystemConfigsResult>(<any>null);
    }

    /**
     * Find all class statuses
     * @return successful operation
     */
    findLeadStages3(): Promise<FindSomeSystemConfigsResult> {
        let url_ = this.baseUrl + "/system-config/lead-class-stage-status/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadStages3(_response);
        });
    }

    protected processFindLeadStages3(response: Response): Promise<FindSomeSystemConfigsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindSomeSystemConfigsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindSomeSystemConfigsResult>(<any>null);
    }

    /**
     * Find all sources
     * @return successful operation
     */
    findProspectingSources(): Promise<FindSomeSystemConfigsResult> {
        let url_ = this.baseUrl + "/system-config/prospecting-source/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProspectingSources(_response);
        });
    }

    protected processFindProspectingSources(response: Response): Promise<FindSomeSystemConfigsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindSomeSystemConfigsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindSomeSystemConfigsResult>(<any>null);
    }

    /**
     * Find stage status by stageId
     * @param stageId stageId
     * @return successful operation
     */
    findLeadStageStatusesByStageId(stageId: string): Promise<FindSomeSystemConfigsResult> {
        let url_ = this.baseUrl + "/system-config/lead-stage-status/{stageId}";
        if (stageId === undefined || stageId === null)
            throw new Error("The parameter 'stageId' must be defined.");
        url_ = url_.replace("{stageId}", encodeURIComponent("" + stageId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadStageStatusesByStageId(_response);
        });
    }

    protected processFindLeadStageStatusesByStageId(response: Response): Promise<FindSomeSystemConfigsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindSomeSystemConfigsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindSomeSystemConfigsResult>(<any>null);
    }

    /**
     * Find stage status
     * @return successful operation
     */
    findLeadStageStatus(): Promise<FindSomeSystemConfigsResult> {
        let url_ = this.baseUrl + "/system-config/lead-stage-status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadStageStatus(_response);
        });
    }

    protected processFindLeadStageStatus(response: Response): Promise<FindSomeSystemConfigsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindSomeSystemConfigsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindSomeSystemConfigsResult>(<any>null);
    }

    /**
     * Find lead stage by name
     * @param name name
     * @return successful operation
     */
    findLeadStageByName(name: string): Promise<FindOneSystemConfigResult> {
        let url_ = this.baseUrl + "/system-config/lead-stage-by-name?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadStageByName(_response);
        });
    }

    protected processFindLeadStageByName(response: Response): Promise<FindOneSystemConfigResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindOneSystemConfigResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindOneSystemConfigResult>(<any>null);
    }

    /**
     * Find lead status by name
     * @param name name
     * @return successful operation
     */
    findLeadStatusByName(name: string): Promise<FindOneSystemConfigResult> {
        let url_ = this.baseUrl + "/system-config/lead-status-by-name?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadStatusByName(_response);
        });
    }

    protected processFindLeadStatusByName(response: Response): Promise<FindOneSystemConfigResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindOneSystemConfigResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindOneSystemConfigResult>(<any>null);
    }

    /**
     * Find class stage by name
     * @param name name
     * @return successful operation
     */
    findClassStageByName(name: string): Promise<FindOneSystemConfigResult> {
        let url_ = this.baseUrl + "/system-config/class-stage-by-name?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindClassStageByName(_response);
        });
    }

    protected processFindClassStageByName(response: Response): Promise<FindOneSystemConfigResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindOneSystemConfigResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindOneSystemConfigResult>(<any>null);
    }

    /**
     * Find class status by name
     * @param name name
     * @return successful operation
     */
    findClassStatusByName(name: string): Promise<FindOneSystemConfigResult> {
        let url_ = this.baseUrl + "/system-config/class-status-by-name?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindClassStatusByName(_response);
        });
    }

    protected processFindClassStatusByName(response: Response): Promise<FindOneSystemConfigResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindOneSystemConfigResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindOneSystemConfigResult>(<any>null);
    }

    /**
     * Find contact stage by name
     * @param name name
     * @return successful operation
     */
    findContactStageByName(name: string): Promise<FindOneSystemConfigResult> {
        let url_ = this.baseUrl + "/system-config/contact-stage-by-name?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindContactStageByName(_response);
        });
    }

    protected processFindContactStageByName(response: Response): Promise<FindOneSystemConfigResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindOneSystemConfigResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindOneSystemConfigResult>(<any>null);
    }

    /**
     * Find contact stage by name
     * @param name name
     * @return successful operation
     */
    findContactStageByName2(name: string): Promise<FindOneSystemConfigResult> {
        let url_ = this.baseUrl + "/system-config/contact-status-by-name?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindContactStageByName2(_response);
        });
    }

    protected processFindContactStageByName2(response: Response): Promise<FindOneSystemConfigResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindOneSystemConfigResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindOneSystemConfigResult>(<any>null);
    }

    /**
     * Find list by id
     * @param listId listId
     * @return successful operation
     */
    findListById(listId: string): Promise<List> {
        let url_ = this.baseUrl + "/lists/{listId}";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined.");
        url_ = url_.replace("{listId}", encodeURIComponent("" + listId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindListById(_response);
        });
    }

    protected processFindListById(response: Response): Promise<List> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <List>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<List>(<any>null);
    }

    /**
     * Update list
     * @param listId listId
     * @param body (optional) 
     * @return successful operation
     */
    updateList(listId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/lists/{listId}";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined.");
        url_ = url_.replace("{listId}", encodeURIComponent("" + listId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateList(_response);
        });
    }

    protected processUpdateList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find lists
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findLists(search: string | undefined, filter: any[] | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindListsResult> {
        let url_ = this.baseUrl + "/lists?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLists(_response);
        });
    }

    protected processFindLists(response: Response): Promise<FindListsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindListsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindListsResult>(<any>null);
    }

    /**
     * Create list
     * @param body (optional) 
     * @return successful operation
     */
    createList(body: any | undefined): Promise<List> {
        let url_ = this.baseUrl + "/lists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateList(_response);
        });
    }

    protected processCreateList(response: Response): Promise<List> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <List>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <List>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<List>(<any>null);
    }

    /**
     * Find root contact by id
     * @param rootContactId rootContactId
     * @return successful operation
     */
    findRootContactById(rootContactId: string): Promise<Contact> {
        let url_ = this.baseUrl + "/root-contact/{rootContactId}";
        if (rootContactId === undefined || rootContactId === null)
            throw new Error("The parameter 'rootContactId' must be defined.");
        url_ = url_.replace("{rootContactId}", encodeURIComponent("" + rootContactId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindRootContactById(_response);
        });
    }

    protected processFindRootContactById(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Contact>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * Update root contact
     * @param rootContactId rootContactId
     * @param body (optional) 
     * @return successful operation
     */
    updateRootContact(rootContactId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/root-contact/{rootContactId}";
        if (rootContactId === undefined || rootContactId === null)
            throw new Error("The parameter 'rootContactId' must be defined.");
        url_ = url_.replace("{rootContactId}", encodeURIComponent("" + rootContactId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRootContact(_response);
        });
    }

    protected processUpdateRootContact(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find mapping
     * @param key (optional) key
     * @param operation (optional) operation
     * @return successful operation
     */
    findMapping(key: string | undefined, operation: string | undefined): Promise<MappingContactInfo[]> {
        let url_ = this.baseUrl + "/mapping-contact-info?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindMapping(_response);
        });
    }

    protected processFindMapping(response: Response): Promise<MappingContactInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MappingContactInfo[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MappingContactInfo[]>(<any>null);
    }

    /**
     * Find mapping by id
     * @param mappingContactInfoId cenmappingContactInfoIdtreId
     * @return successful operation
     */
    findMappingById(mappingContactInfoId: string): Promise<MappingContactInfo> {
        let url_ = this.baseUrl + "/mapping-contact-info/{mappingContactInfoId}";
        if (mappingContactInfoId === undefined || mappingContactInfoId === null)
            throw new Error("The parameter 'mappingContactInfoId' must be defined.");
        url_ = url_.replace("{mappingContactInfoId}", encodeURIComponent("" + mappingContactInfoId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindMappingById(_response);
        });
    }

    protected processFindMappingById(response: Response): Promise<MappingContactInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MappingContactInfo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MappingContactInfo>(<any>null);
    }

    /**
     * Find class
     * @param operation (optional) operation service will take on
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findClasses(operation: string | undefined, search: string | undefined, filter: any[] | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindClassesResult> {
        let url_ = this.baseUrl + "/class?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindClasses(_response);
        });
    }

    protected processFindClasses(response: Response): Promise<FindClassesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindClassesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindClassesResult>(<any>null);
    }

    /**
     * Create class
     * @param body (optional) 
     * @return successful operation
     */
    createClass(body: any | undefined): Promise<Class> {
        let url_ = this.baseUrl + "/class";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateClass(_response);
        });
    }

    protected processCreateClass(response: Response): Promise<Class> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Class>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Class>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Class>(<any>null);
    }

    /**
     * getAllClasses
     * @return successful operation
     */
    getAllClasses(): Promise<FindAllClassesResult> {
        let url_ = this.baseUrl + "/class/get-all-class";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllClasses(_response);
        });
    }

    protected processGetAllClasses(response: Response): Promise<FindAllClassesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllClassesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllClassesResult>(<any>null);
    }

    /**
     * synchronizeClass
     * @return successful operation
     */
    synchronizeClass(): Promise<FindAllClassesResult> {
        let url_ = this.baseUrl + "/class/sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSynchronizeClass(_response);
        });
    }

    protected processSynchronizeClass(response: Response): Promise<FindAllClassesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllClassesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllClassesResult>(<any>null);
    }

    /**
     * Delete combo
     * @param productComboId productComboId
     * @return successful operation
     */
    deleteProductCombo(productComboId: string): Promise<void> {
        let url_ = this.baseUrl + "/product-combo/{productComboId}";
        if (productComboId === undefined || productComboId === null)
            throw new Error("The parameter 'productComboId' must be defined.");
        url_ = url_.replace("{productComboId}", encodeURIComponent("" + productComboId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductCombo(_response);
        });
    }

    protected processDeleteProductCombo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find product combo by id
     * @param productComboId productComboId
     * @return successful operation
     */
    findProductComboById(productComboId: string): Promise<ProductCombo> {
        let url_ = this.baseUrl + "/product-combo/{productComboId}";
        if (productComboId === undefined || productComboId === null)
            throw new Error("The parameter 'productComboId' must be defined.");
        url_ = url_.replace("{productComboId}", encodeURIComponent("" + productComboId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProductComboById(_response);
        });
    }

    protected processFindProductComboById(response: Response): Promise<ProductCombo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProductCombo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCombo>(<any>null);
    }

    /**
     * Update Product Combo
     * @param productComboId productComboId
     * @param body (optional) 
     * @return successful operation
     */
    updateProductCombo(productComboId: string, body: any | undefined): Promise<ProductCombo> {
        let url_ = this.baseUrl + "/product-combo/{productComboId}";
        if (productComboId === undefined || productComboId === null)
            throw new Error("The parameter 'productComboId' must be defined.");
        url_ = url_.replace("{productComboId}", encodeURIComponent("" + productComboId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductCombo(_response);
        });
    }

    protected processUpdateProductCombo(response: Response): Promise<ProductCombo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProductCombo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <ProductCombo>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCombo>(<any>null);
    }

    /**
     * Find product combo
     * @param operation (optional) operation service will take on
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findProductCombo(operation: string | undefined, search: string | undefined, filter: any[] | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindProductComboResult> {
        let url_ = this.baseUrl + "/product-combo?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProductCombo(_response);
        });
    }

    protected processFindProductCombo(response: Response): Promise<FindProductComboResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindProductComboResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindProductComboResult>(<any>null);
    }

    /**
     * Create product combo
     * @param body (optional) 
     * @return successful operation
     */
    createProductCombo(body: any | undefined): Promise<ProductCombo> {
        let url_ = this.baseUrl + "/product-combo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProductCombo(_response);
        });
    }

    protected processCreateProductCombo(response: Response): Promise<ProductCombo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProductCombo>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <ProductCombo>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCombo>(<any>null);
    }

    /**
     * Get all product combo
     * @return successful operation
     */
    getAllProductCombo(): Promise<FindAllProductComboResult> {
        let url_ = this.baseUrl + "/product-combo/get-all-combos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProductCombo(_response);
        });
    }

    protected processGetAllProductCombo(response: Response): Promise<FindAllProductComboResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllProductComboResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllProductComboResult>(<any>null);
    }

    /**
     * Find product course by id
     * @param productCourseId productCourseId
     * @return successful operation
     */
    findProductCourseById(productCourseId: string): Promise<ProductCourse> {
        let url_ = this.baseUrl + "/product-course/{productCourseId}";
        if (productCourseId === undefined || productCourseId === null)
            throw new Error("The parameter 'productCourseId' must be defined.");
        url_ = url_.replace("{productCourseId}", encodeURIComponent("" + productCourseId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProductCourseById(_response);
        });
    }

    protected processFindProductCourseById(response: Response): Promise<ProductCourse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProductCourse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCourse>(<any>null);
    }

    /**
     * Update Product Course
     * @param productCourseId productCourseId
     * @param body (optional) 
     * @return successful operation
     */
    updateProductCourse(productCourseId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/product-course/{productCourseId}";
        if (productCourseId === undefined || productCourseId === null)
            throw new Error("The parameter 'productCourseId' must be defined.");
        url_ = url_.replace("{productCourseId}", encodeURIComponent("" + productCourseId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductCourse(_response);
        });
    }

    protected processUpdateProductCourse(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find product course
     * @param operation (optional) operation service will take on
     * @param search (optional) search
     * @param filter (optional) filters
     * @param first (optional) number of records returned
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findProductCourse(operation: string | undefined, search: string | undefined, filter: any[] | undefined, first: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined): Promise<FindProductCourseResult> {
        let url_ = this.baseUrl + "/product-course?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProductCourse(_response);
        });
    }

    protected processFindProductCourse(response: Response): Promise<FindProductCourseResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindProductCourseResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindProductCourseResult>(<any>null);
    }

    /**
     * Create product course
     * @param body (optional) 
     * @return successful operation
     */
    createProductCourse(body: any | undefined): Promise<ProductCourse> {
        let url_ = this.baseUrl + "/product-course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProductCourse(_response);
        });
    }

    protected processCreateProductCourse(response: Response): Promise<ProductCourse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProductCourse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <ProductCourse>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCourse>(<any>null);
    }

    /**
     * Find all product course
     * @return successful operation
     */
    getAllProductCourse(): Promise<FindAllProductCourseResult> {
        let url_ = this.baseUrl + "/product-course/get-all-courses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProductCourse(_response);
        });
    }

    protected processGetAllProductCourse(response: Response): Promise<FindAllProductCourseResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllProductCourseResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllProductCourseResult>(<any>null);
    }

    /**
     * synchronizeCourse
     * @return successful operation
     */
    synchronizeCourse(): Promise<FindAllProductCourseResult> {
        let url_ = this.baseUrl + "/product-course/sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSynchronizeCourse(_response);
        });
    }

    protected processSynchronizeCourse(response: Response): Promise<FindAllProductCourseResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllProductCourseResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllProductCourseResult>(<any>null);
    }

    /**
     * Find lead product order by id
     * @param leadProductOrderId leadProductOrderId
     * @return successful operation
     */
    findLeadProductOrderById(leadProductOrderId: string): Promise<LeadProductOrder> {
        let url_ = this.baseUrl + "/lead-product-order/{leadProductOrderId}";
        if (leadProductOrderId === undefined || leadProductOrderId === null)
            throw new Error("The parameter 'leadProductOrderId' must be defined.");
        url_ = url_.replace("{leadProductOrderId}", encodeURIComponent("" + leadProductOrderId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadProductOrderById(_response);
        });
    }

    protected processFindLeadProductOrderById(response: Response): Promise<LeadProductOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadProductOrder>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadProductOrder>(<any>null);
    }

    /**
     * Update Lead Product Order
     * @param leadProductOrderId leadProductOrderId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadProductOrder(leadProductOrderId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/lead-product-order/{leadProductOrderId}";
        if (leadProductOrderId === undefined || leadProductOrderId === null)
            throw new Error("The parameter 'leadProductOrderId' must be defined.");
        url_ = url_.replace("{leadProductOrderId}", encodeURIComponent("" + leadProductOrderId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadProductOrder(_response);
        });
    }

    protected processUpdateLeadProductOrder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find Lead Product Order
     * @return successful operation
     */
    findLeadProductOrder(): Promise<FindLeadProductOrderResult> {
        let url_ = this.baseUrl + "/lead-product-order";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadProductOrder(_response);
        });
    }

    protected processFindLeadProductOrder(response: Response): Promise<FindLeadProductOrderResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLeadProductOrderResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLeadProductOrderResult>(<any>null);
    }

    /**
     * Create Lead Product Order
     * @param body (optional) 
     * @return successful operation
     */
    createLeadProductOrder(body: any | undefined): Promise<LeadProductOrder> {
        let url_ = this.baseUrl + "/lead-product-order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadProductOrder(_response);
        });
    }

    protected processCreateLeadProductOrder(response: Response): Promise<LeadProductOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LeadProductOrder>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LeadProductOrder>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadProductOrder>(<any>null);
    }

    /**
     * Find centre by id
     * @param centreId centreId
     * @return successful operation
     */
    findCentreById(centreId: string): Promise<Centre> {
        let url_ = this.baseUrl + "/centre/{centreId}";
        if (centreId === undefined || centreId === null)
            throw new Error("The parameter 'centreId' must be defined.");
        url_ = url_.replace("{centreId}", encodeURIComponent("" + centreId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindCentreById(_response);
        });
    }

    protected processFindCentreById(response: Response): Promise<Centre> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Centre>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Centre>(<any>null);
    }

    /**
     * Update centre
     * @param centreId centreId
     * @param body (optional) 
     * @return successful operation
     */
    updateCentre(centreId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/centre/{centreId}";
        if (centreId === undefined || centreId === null)
            throw new Error("The parameter 'centreId' must be defined.");
        url_ = url_.replace("{centreId}", encodeURIComponent("" + centreId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCentre(_response);
        });
    }

    protected processUpdateCentre(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Centre
     * @param assignable (optional) Only get centres to assign
     * @return successful operation
     */
    getCentres(assignable: boolean | undefined): Promise<FindAllCentresResult> {
        let url_ = this.baseUrl + "/centre?";
        if (assignable === null)
            throw new Error("The parameter 'assignable' cannot be null.");
        else if (assignable !== undefined)
            url_ += "assignable=" + encodeURIComponent("" + assignable) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCentres(_response);
        });
    }

    protected processGetCentres(response: Response): Promise<FindAllCentresResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllCentresResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllCentresResult>(<any>null);
    }

    /**
     * Create centre
     * @param body (optional) 
     * @return successful operation
     */
    createCentre(body: any | undefined): Promise<Centre> {
        let url_ = this.baseUrl + "/centre";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCentre(_response);
        });
    }

    protected processCreateCentre(response: Response): Promise<Centre> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Centre>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Centre>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Centre>(<any>null);
    }

    /**
     * getAllCentres
     * @return successful operation
     */
    getAllCentres(): Promise<FindAllCentresResult> {
        let url_ = this.baseUrl + "/centre/get-all-centre";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCentres(_response);
        });
    }

    protected processGetAllCentres(response: Response): Promise<FindAllCentresResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllCentresResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllCentresResult>(<any>null);
    }

    /**
     * synchronizeCentre
     * @return successful operation
     */
    synchronizeCentre(): Promise<FindAllCentresResult> {
        let url_ = this.baseUrl + "/centre/sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSynchronizeCentre(_response);
        });
    }

    protected processSynchronizeCentre(response: Response): Promise<FindAllCentresResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllCentresResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllCentresResult>(<any>null);
    }

    /**
     * checkContactExistsByPhoneNumber
     * @param phoneNumber phoneNumber
     * @return successful operation
     */
    checkContactExistsByPhoneNumber(phoneNumber: string): Promise<Contact> {
        let url_ = this.baseUrl + "/contact/customs/check-phone-number-exists/{phoneNumber}";
        if (phoneNumber === undefined || phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' must be defined.");
        url_ = url_.replace("{phoneNumber}", encodeURIComponent("" + phoneNumber)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckContactExistsByPhoneNumber(_response);
        });
    }

    protected processCheckContactExistsByPhoneNumber(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Contact>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * getSummary
     * @param listId listId
     * @return successful operation
     */
    getSummary(listId: string): Promise<ContactSummary> {
        let url_ = this.baseUrl + "/contact/customs/summary?";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined and cannot be null.");
        else
            url_ += "listId=" + encodeURIComponent("" + listId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: Response): Promise<ContactSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContactSummary>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactSummary>(<any>null);
    }

    /**
     * findContactById
     * @param contactId contactId
     * @return successful operation
     */
    findContactById(contactId: string): Promise<Contact> {
        let url_ = this.baseUrl + "/contact/{contactId}";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindContactById(_response);
        });
    }

    protected processFindContactById(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Contact>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * Update contact
     * @param contactId contactId
     * @return successful operation
     */
    updateContact(contactId: string, body: UpdateContactDetailPayload): Promise<Contact> {
        let url_ = this.baseUrl + "/contact/{contactId}";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContact(_response);
        });
    }

    protected processUpdateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Contact>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * Find contacts
     * @param search (optional) search
     * @param limit (optional) number of records returned
     * @param page (optional) current page
     * @param sortBy (optional) sort field
     * @return successful operation
     */
    findContacts(search: string | undefined, limit: number | undefined, page: number | undefined, sortBy: string | undefined): Promise<FindContactsResult> {
        let url_ = this.baseUrl + "/contact?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindContacts(_response);
        });
    }

    protected processFindContacts(response: Response): Promise<FindContactsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindContactsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindContactsResult>(<any>null);
    }

    /**
     * Create contact
     * @param body (optional) 
     * @return successful operation
     */
    createContact(body: any | undefined): Promise<Contact> {
        let url_ = this.baseUrl + "/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContact(_response);
        });
    }

    protected processCreateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Contact>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Contact>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * Find active lead by phone number
     * @param phoneNumber phoneNumber
     * @return successful operation
     */
    findActiveLeadByPhoneNumber(phoneNumber: string): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/get-active-lead-by-phone-number/{phoneNumber}";
        if (phoneNumber === undefined || phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' must be defined.");
        url_ = url_.replace("{phoneNumber}", encodeURIComponent("" + phoneNumber)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindActiveLeadByPhoneNumber(_response);
        });
    }

    protected processFindActiveLeadByPhoneNumber(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Find lead by id
     * @param leadId leadId
     * @return successful operation
     */
    findLeadById(leadId: string): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeadById(_response);
        });
    }

    protected processFindLeadById(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Update lead
     * @param leadId leadId
     * @param body (optional) 
     * @return successful operation
     */
    updateLead(leadId: string, body: any | undefined): Promise<PatchResponse> {
        let url_ = this.baseUrl + "/leads/{leadId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLead(_response);
        });
    }

    protected processUpdateLead(response: Response): Promise<PatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PatchResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PatchResponse>(<any>null);
    }

    /**
     * Create lead reminder
     * @param leadId leadId
     * @param body (optional) 
     * @return successful operation
     */
    createLeadReminder(leadId: string, body: any | undefined): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/reminders";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadReminder(_response);
        });
    }

    protected processCreateLeadReminder(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Update lead reminder
     * @param leadId leadId
     * @param reminderId reminderId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadReminder(leadId: string, reminderId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/leads/{leadId}/reminders/{reminderId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        if (reminderId === undefined || reminderId === null)
            throw new Error("The parameter 'reminderId' must be defined.");
        url_ = url_.replace("{reminderId}", encodeURIComponent("" + reminderId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadReminder(_response);
        });
    }

    protected processUpdateLeadReminder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create lead note
     * @param leadId leadId
     * @param body (optional) 
     * @return successful operation
     */
    addLeadNote(leadId: string, body: any | undefined): Promise<LeadNote> {
        let url_ = this.baseUrl + "/leads/{leadId}/notes";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLeadNote(_response);
        });
    }

    protected processAddLeadNote(response: Response): Promise<LeadNote> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LeadNote>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeadNote>(<any>null);
    }

    /**
     * Create lead appointment
     * @param leadId leadId
     * @param body (optional) 
     * @return successful operation
     */
    addLeadAppointment(leadId: string, body: any | undefined): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/appointments";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLeadAppointment(_response);
        });
    }

    protected processAddLeadAppointment(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Update lead appointment
     * @param leadId leadId
     * @param appointmentId appointmentId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadAppointmentStatus(leadId: string, appointmentId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/leads/{leadId}/appointments/{appointmentId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        if (appointmentId === undefined || appointmentId === null)
            throw new Error("The parameter 'appointmentId' must be defined.");
        url_ = url_.replace("{appointmentId}", encodeURIComponent("" + appointmentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadAppointmentStatus(_response);
        });
    }

    protected processUpdateLeadAppointmentStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create lead family member
     * @param leadId leadId
     * @param body (optional) 
     * @return successful operation
     */
    addLeadFamilyMember(leadId: string, body: any | undefined): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/family";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLeadFamilyMember(_response);
        });
    }

    protected processAddLeadFamilyMember(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Update lead family member
     * @param leadId leadId
     * @param familyMemberId familyMemberId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadFamilyMember(leadId: string, familyMemberId: string, body: any | undefined): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/family/{familyMemberId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        if (familyMemberId === undefined || familyMemberId === null)
            throw new Error("The parameter 'familyMemberId' must be defined.");
        url_ = url_.replace("{familyMemberId}", encodeURIComponent("" + familyMemberId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadFamilyMember(_response);
        });
    }

    protected processUpdateLeadFamilyMember(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Update lead customer
     * @param leadId leadId
     * @param body (optional) 
     * @return successful operation
     */
    updateLeadCustomer(leadId: string, body: any | undefined): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/customer";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadCustomer(_response);
        });
    }

    protected processUpdateLeadCustomer(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Create lead order
     * @param leadId leadId
     * @return successful operation
     */
    createLeadOrder(leadId: string, body: CreateLeadOrderPayload): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/order";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLeadOrder(_response);
        });
    }

    protected processCreateLeadOrder(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Add lead payment
     * @param leadId leadId
     * @return successful operation
     */
    addLeadPayment(leadId: string, body: LeadPaymentItem): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/payment";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLeadPayment(_response);
        });
    }

    protected processAddLeadPayment(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Add lead refund
     * @param leadId leadId
     * @return successful operation
     */
    addLeadRefund(leadId: string, body: LeadRefundItem): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/refund";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLeadRefund(_response);
        });
    }

    protected processAddLeadRefund(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Update lead product
     * @param leadId leadId
     * @return successful operation
     */
    updateLeadProducts(leadId: string, body: UpdateLeadProductsPayload): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/products";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeadProducts(_response);
        });
    }

    protected processUpdateLeadProducts(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Add product enrollment imte
     * @param leadId leadId
     * @param productItemId productItemId
     * @return successful operation
     */
    addProductEnrollmentItem(leadId: string, productItemId: string, body: UpdateProductEnrollmentItemPayload): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/order/{productItemId}/enrollments";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        if (productItemId === undefined || productItemId === null)
            throw new Error("The parameter 'productItemId' must be defined.");
        url_ = url_.replace("{productItemId}", encodeURIComponent("" + productItemId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductEnrollmentItem(_response);
        });
    }

    protected processAddProductEnrollmentItem(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Add order product item
     * @param leadId leadId
     * @return successful operation
     */
    addOrderProductItem(leadId: string, body: LeadOrderProductItemPayload): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/order/productItems";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddOrderProductItem(_response);
        });
    }

    protected processAddOrderProductItem(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Update product enrollment item
     * @param leadId leadId
     * @param productItemId productItemId
     * @param productEnrollmentItemId productEnrollmentItemId
     * @return successful operation
     */
    updateProductEnrollmentItem(leadId: string, productItemId: string, productEnrollmentItemId: string, body: UpdateProductEnrollmentItemPayload): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/order/{productItemId}/enrollments/{productEnrollmentItemId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        if (productItemId === undefined || productItemId === null)
            throw new Error("The parameter 'productItemId' must be defined.");
        url_ = url_.replace("{productItemId}", encodeURIComponent("" + productItemId)); 
        if (productEnrollmentItemId === undefined || productEnrollmentItemId === null)
            throw new Error("The parameter 'productEnrollmentItemId' must be defined.");
        url_ = url_.replace("{productEnrollmentItemId}", encodeURIComponent("" + productEnrollmentItemId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductEnrollmentItem(_response);
        });
    }

    protected processUpdateProductEnrollmentItem(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Send enrollment request
     * @param leadId leadId
     * @param productItemId productItemId
     * @param productEnrollmentItemId productEnrollmentItemId
     * @return successful operation
     */
    sendEnrollmentRequest(leadId: string, productItemId: string, productEnrollmentItemId: string): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/order/{productItemId}/enrollments/{productEnrollmentItemId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        if (productItemId === undefined || productItemId === null)
            throw new Error("The parameter 'productItemId' must be defined.");
        url_ = url_.replace("{productItemId}", encodeURIComponent("" + productItemId)); 
        if (productEnrollmentItemId === undefined || productEnrollmentItemId === null)
            throw new Error("The parameter 'productEnrollmentItemId' must be defined.");
        url_ = url_.replace("{productEnrollmentItemId}", encodeURIComponent("" + productEnrollmentItemId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendEnrollmentRequest(_response);
        });
    }

    protected processSendEnrollmentRequest(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Cancel enrollment request
     * @param leadId leadId
     * @param productItemId productItemId
     * @param productEnrollmentItemId productEnrollmentItemId
     * @return successful operation
     */
    cancelEnrollmentRequest(leadId: string, productItemId: string, productEnrollmentItemId: string): Promise<Lead> {
        let url_ = this.baseUrl + "/leads/{leadId}/order/{productItemId}/enrollments/{productEnrollmentItemId}";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined.");
        url_ = url_.replace("{leadId}", encodeURIComponent("" + leadId)); 
        if (productItemId === undefined || productItemId === null)
            throw new Error("The parameter 'productItemId' must be defined.");
        url_ = url_.replace("{productItemId}", encodeURIComponent("" + productItemId)); 
        if (productEnrollmentItemId === undefined || productEnrollmentItemId === null)
            throw new Error("The parameter 'productEnrollmentItemId' must be defined.");
        url_ = url_.replace("{productEnrollmentItemId}", encodeURIComponent("" + productEnrollmentItemId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelEnrollmentRequest(_response);
        });
    }

    protected processCancelEnrollmentRequest(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Find leads
     * @param operation (optional) operation
     * @param search (optional) search
     * @param filter (optional) filters
     * @param limit (optional) number of records returned
     * @param page (optional) current page
     * @param sortBy (optional) sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @param stage (optional) Specified sale stage
     * @param channel (optional) Specified channel
     * @param status (optional) Specified sale status
     * @param reminderStart (optional) Reminder filter starting date range, in ISO8061 string
     * @param reminderEnd (optional) Reminder filter ending date range, in ISO8061 string
     * @param tuitionPaidPercent (optional) Tuition range
     * @param appointmentStart (optional) Appointment filter starting date range, in ISO8061 string
     * @param appointmentEnd (optional) Appointment filter ending date range, in ISO8061 string
     * @param product (optional) Product purchased
     * @param createdAtStart (optional) Created at filter starting date range, in ISO8061 string
     * @param createdAtEnd (optional) Created at filter ending date range, in ISO8061 string
     * @param owner (optional) owner's id, set to 'no-owner' in case of searching for unowned leads
     * @param centreId (optional) centre's id, set to 'no-owner' in case of searching for leads not belong to any centres
     * @param lmsCourse (optional) Course's id
     * @param lmsClass (optional) Class's id
     * @param lmsEnrollmentStatus (optional) LMS enrollment status
     * @return successful operation
     */
    findLeads(operation: string | undefined, search: string | undefined, filter: any[] | undefined, limit: number | undefined, page: number | undefined, sortBy: string | undefined, before: string | undefined, after: string | undefined, stage: string[] | undefined, channel: string[] | undefined, status: string[] | undefined, reminderStart: string | undefined, reminderEnd: string | undefined, tuitionPaidPercent: TuitionPaidPercent | undefined, appointmentStart: string | undefined, appointmentEnd: string | undefined, product: string | undefined, createdAtStart: string | undefined, createdAtEnd: string | undefined, owner: string | undefined, centreId: string | undefined, lmsCourse: string | undefined, lmsClass: string | undefined, lmsEnrollmentStatus: LmsEnrollmentStatus | undefined): Promise<Lead> {
        let url_ = this.baseUrl + "/leads?";
        if (operation === null)
            throw new Error("The parameter 'operation' cannot be null.");
        else if (operation !== undefined)
            url_ += "operation=" + encodeURIComponent("" + operation) + "&"; 
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        if (stage === null)
            throw new Error("The parameter 'stage' cannot be null.");
        else if (stage !== undefined)
            stage && stage.forEach(item => { url_ += "stage=" + encodeURIComponent("" + item) + "&"; });
        if (channel === null)
            throw new Error("The parameter 'channel' cannot be null.");
        else if (channel !== undefined)
            channel && channel.forEach(item => { url_ += "channel=" + encodeURIComponent("" + item) + "&"; });
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "status=" + encodeURIComponent("" + item) + "&"; });
        if (reminderStart === null)
            throw new Error("The parameter 'reminderStart' cannot be null.");
        else if (reminderStart !== undefined)
            url_ += "reminderStart=" + encodeURIComponent("" + reminderStart) + "&"; 
        if (reminderEnd === null)
            throw new Error("The parameter 'reminderEnd' cannot be null.");
        else if (reminderEnd !== undefined)
            url_ += "reminderEnd=" + encodeURIComponent("" + reminderEnd) + "&"; 
        if (tuitionPaidPercent === null)
            throw new Error("The parameter 'tuitionPaidPercent' cannot be null.");
        else if (tuitionPaidPercent !== undefined)
            url_ += "tuitionPaidPercent=" + encodeURIComponent("" + tuitionPaidPercent) + "&"; 
        if (appointmentStart === null)
            throw new Error("The parameter 'appointmentStart' cannot be null.");
        else if (appointmentStart !== undefined)
            url_ += "appointmentStart=" + encodeURIComponent("" + appointmentStart) + "&"; 
        if (appointmentEnd === null)
            throw new Error("The parameter 'appointmentEnd' cannot be null.");
        else if (appointmentEnd !== undefined)
            url_ += "appointmentEnd=" + encodeURIComponent("" + appointmentEnd) + "&"; 
        if (product === null)
            throw new Error("The parameter 'product' cannot be null.");
        else if (product !== undefined)
            url_ += "product=" + encodeURIComponent("" + product) + "&"; 
        if (createdAtStart === null)
            throw new Error("The parameter 'createdAtStart' cannot be null.");
        else if (createdAtStart !== undefined)
            url_ += "createdAtStart=" + encodeURIComponent("" + createdAtStart) + "&"; 
        if (createdAtEnd === null)
            throw new Error("The parameter 'createdAtEnd' cannot be null.");
        else if (createdAtEnd !== undefined)
            url_ += "createdAtEnd=" + encodeURIComponent("" + createdAtEnd) + "&"; 
        if (owner === null)
            throw new Error("The parameter 'owner' cannot be null.");
        else if (owner !== undefined)
            url_ += "owner=" + encodeURIComponent("" + owner) + "&"; 
        if (centreId === null)
            throw new Error("The parameter 'centreId' cannot be null.");
        else if (centreId !== undefined)
            url_ += "centreId=" + encodeURIComponent("" + centreId) + "&"; 
        if (lmsCourse === null)
            throw new Error("The parameter 'lmsCourse' cannot be null.");
        else if (lmsCourse !== undefined)
            url_ += "lmsCourse=" + encodeURIComponent("" + lmsCourse) + "&"; 
        if (lmsClass === null)
            throw new Error("The parameter 'lmsClass' cannot be null.");
        else if (lmsClass !== undefined)
            url_ += "lmsClass=" + encodeURIComponent("" + lmsClass) + "&"; 
        if (lmsEnrollmentStatus === null)
            throw new Error("The parameter 'lmsEnrollmentStatus' cannot be null.");
        else if (lmsEnrollmentStatus !== undefined)
            url_ += "lmsEnrollmentStatus=" + encodeURIComponent("" + lmsEnrollmentStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeads(_response);
        });
    }

    protected processFindLeads(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Create lead
     * @param body (optional) 
     * @return successful operation
     */
    createLead(body: any | undefined): Promise<Lead> {
        let url_ = this.baseUrl + "/leads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLead(_response);
        });
    }

    protected processCreateLead(response: Response): Promise<Lead> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Lead>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lead>(<any>null);
    }

    /**
     * Find Lms categories
     * @return successful operation
     */
    findLmsCategories(): Promise<FindLmsCategoryResult> {
        let url_ = this.baseUrl + "/lms-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLmsCategories(_response);
        });
    }

    protected processFindLmsCategories(response: Response): Promise<FindLmsCategoryResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLmsCategoryResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLmsCategoryResult>(<any>null);
    }

    /**
     * findLmsClassById
     * @param lmsClassId lmsClassId
     * @return successful operation
     */
    findLmsClassById(lmsClassId: string): Promise<LmsClass> {
        let url_ = this.baseUrl + "/lms-classes/{lmsClassId}";
        if (lmsClassId === undefined || lmsClassId === null)
            throw new Error("The parameter 'lmsClassId' must be defined.");
        url_ = url_.replace("{lmsClassId}", encodeURIComponent("" + lmsClassId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLmsClassById(_response);
        });
    }

    protected processFindLmsClassById(response: Response): Promise<LmsClass> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LmsClass>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LmsClass>(<any>null);
    }

    /**
     * Find Lms classes
     * @param search (optional) search
     * @param lmsCourse (optional) Lms Course to find
     * @param limit (optional) number of records returned
     * @param page (optional) current page
     * @param sortBy (optional) sort field
     * @return successful operation
     */
    findLmsClasses(search: string | undefined, lmsCourse: string[] | undefined, limit: number | undefined, page: number | undefined, sortBy: string | undefined): Promise<FindLmsClassResult> {
        let url_ = this.baseUrl + "/lms-classes?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (lmsCourse === null)
            throw new Error("The parameter 'lmsCourse' cannot be null.");
        else if (lmsCourse !== undefined)
            lmsCourse && lmsCourse.forEach(item => { url_ += "lmsCourse=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLmsClasses(_response);
        });
    }

    protected processFindLmsClasses(response: Response): Promise<FindLmsClassResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLmsClassResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLmsClassResult>(<any>null);
    }

    /**
     * findLmsCourseById
     * @param lmsCourseId lmsCourseId
     * @return successful operation
     */
    findLmsCourseById(lmsCourseId: string): Promise<LmsCourse> {
        let url_ = this.baseUrl + "/lms-courses/{lmsCourseId}";
        if (lmsCourseId === undefined || lmsCourseId === null)
            throw new Error("The parameter 'lmsCourseId' must be defined.");
        url_ = url_.replace("{lmsCourseId}", encodeURIComponent("" + lmsCourseId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLmsCourseById(_response);
        });
    }

    protected processFindLmsCourseById(response: Response): Promise<LmsCourse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LmsCourse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LmsCourse>(<any>null);
    }

    /**
     * Find Lms courses
     * @param search (optional) search
     * @param lmsCategory (optional) Lms category to find
     * @param limit (optional) number of records returned
     * @param page (optional) current page
     * @param sortBy (optional) sort field
     * @return successful operation
     */
    findLmsCourses(search: string | undefined, lmsCategory: string[] | undefined, limit: number | undefined, page: number | undefined, sortBy: string | undefined): Promise<FindLmsCourseResult> {
        let url_ = this.baseUrl + "/lms-courses?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (lmsCategory === null)
            throw new Error("The parameter 'lmsCategory' cannot be null.");
        else if (lmsCategory !== undefined)
            lmsCategory && lmsCategory.forEach(item => { url_ += "lmsCategory=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLmsCourses(_response);
        });
    }

    protected processFindLmsCourses(response: Response): Promise<FindLmsCourseResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindLmsCourseResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindLmsCourseResult>(<any>null);
    }

    /**
     * findProductById
     * @param productId productId
     * @return successful operation
     */
    findProductById(productId: string): Promise<Product> {
        let url_ = this.baseUrl + "/products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProductById(_response);
        });
    }

    protected processFindProductById(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Product>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("successful operation", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * Update product
     * @param productId productId
     * @return successful operation
     */
    updateProduct(productId: string, body: UpdateProductPayload): Promise<Product> {
        let url_ = this.baseUrl + "/products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProduct(_response);
        });
    }

    protected processUpdateProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Product>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Product>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * Find products
     * @param search (optional) search
     * @param type (optional) product type filter
     * @param category (optional) product category filter
     * @param productLine (optional) product line filter
     * @param isActive (optional) product status filter
     * @param limit (optional) number of records returned
     * @param page (optional) current page
     * @param sortBy (optional) sort field
     * @return successful operation
     */
    findProducts(search: string | undefined, type: string[] | undefined, category: string[] | undefined, productLine: string[] | undefined, isActive: boolean | undefined, limit: number | undefined, page: number | undefined, sortBy: string | undefined): Promise<FindProductsResult> {
        let url_ = this.baseUrl + "/products?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            type && type.forEach(item => { url_ += "type=" + encodeURIComponent("" + item) + "&"; });
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            category && category.forEach(item => { url_ += "category=" + encodeURIComponent("" + item) + "&"; });
        if (productLine === null)
            throw new Error("The parameter 'productLine' cannot be null.");
        else if (productLine !== undefined)
            productLine && productLine.forEach(item => { url_ += "productLine=" + encodeURIComponent("" + item) + "&"; });
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProducts(_response);
        });
    }

    protected processFindProducts(response: Response): Promise<FindProductsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindProductsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindProductsResult>(<any>null);
    }

    /**
     * Create product
     * @return successful operation
     */
    createProduct(body: CreateProductPayload): Promise<Product> {
        let url_ = this.baseUrl + "/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProduct(_response);
        });
    }

    protected processCreateProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Product>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Product>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * Find users
     * @param search (optional) search
     * @param roles (optional) filter by roles
     * @param centreId (optional) Centre Id
     * @param assignable (optional) Assignable
     * @param filter (optional) custom filter
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findUsers(search: string | undefined, roles: string[] | undefined, centreId: string | undefined, assignable: boolean | undefined, filter: any[] | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindUsersResult> {
        let url_ = this.baseUrl + "/users?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (roles === null)
            throw new Error("The parameter 'roles' cannot be null.");
        else if (roles !== undefined)
            roles && roles.forEach(item => { url_ += "roles=" + encodeURIComponent("" + item) + "&"; });
        if (centreId === null)
            throw new Error("The parameter 'centreId' cannot be null.");
        else if (centreId !== undefined)
            url_ += "centreId=" + encodeURIComponent("" + centreId) + "&"; 
        if (assignable === null)
            throw new Error("The parameter 'assignable' cannot be null.");
        else if (assignable !== undefined)
            url_ += "assignable=" + encodeURIComponent("" + assignable) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "filter[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsers(_response);
        });
    }

    protected processFindUsers(response: Response): Promise<FindUsersResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindUsersResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindUsersResult>(<any>null);
    }

    /**
     * Create user
     * @param body (optional) 
     * @return successful operation
     */
    createUser(body: any | undefined): Promise<User> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Get all users
     * @param search (optional) search
     * @param limit (optional) number of records returned
     * @param page (optional) current page
     * @param sortBy (optional) sort field
     * @return successful operation
     */
    getAllUsers(search: string | undefined, limit: number | undefined, page: number | undefined, sortBy: string | undefined): Promise<FindAllUsersResult> {
        let url_ = this.baseUrl + "/users/get-all-users?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: Response): Promise<FindAllUsersResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllUsersResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllUsersResult>(<any>null);
    }

    /**
     * Get all salesman
     * @return successful operation
     */
    getAllSalesman(): Promise<FindAllUsersResult> {
        let url_ = this.baseUrl + "/users/get-salesman";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSalesman(_response);
        });
    }

    protected processGetAllSalesman(response: Response): Promise<FindAllUsersResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllUsersResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllUsersResult>(<any>null);
    }

    /**
     * Get all interviewers
     * @return successful operation
     */
    getAllInterviewers(): Promise<FindAllUsersResult> {
        let url_ = this.baseUrl + "/users/get-interviewer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllInterviewers(_response);
        });
    }

    protected processGetAllInterviewers(response: Response): Promise<FindAllUsersResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindAllUsersResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("unauthorize", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllUsersResult>(<any>null);
    }

    /**
     * Find permissions by user id
     * @param id userId
     * @return successful operation
     */
    getPermissions(id: string): Promise<PermissionsResult> {
        let url_ = this.baseUrl + "/users/get-permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissions(_response);
        });
    }

    protected processGetPermissions(response: Response): Promise<PermissionsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PermissionsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionsResult>(<any>null);
    }

    /**
     * Find user by id
     * @param userId userId
     * @return successful operation
     */
    findUserById(userId: string): Promise<User> {
        let url_ = this.baseUrl + "/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUserById(_response);
        });
    }

    protected processFindUserById(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Update user
     * @param userId userId
     * @param body (optional) 
     * @return successful operation
     */
    updateUser(userId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Check email exist
     * @param email email
     * @return successful operation
     */
    checkEmailExist(email: string): Promise<CheckEmailExistResult> {
        let url_ = this.baseUrl + "/users/check-email-exist/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckEmailExist(_response);
        });
    }

    protected processCheckEmailExist(response: Response): Promise<CheckEmailExistResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CheckEmailExistResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("bad request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Token is invalid or expired", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("internal server error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckEmailExistResult>(<any>null);
    }
}

export interface GetAllRolesResult {
    roles: Role[];
}

export interface CheckRoleNameExistResult {
    roleNameExist: boolean;
}

export interface FindPermissionsResult {
}

export interface RegisterUserPayload {
    idToken: string;
}

export interface FindRolesResult {
    data: Role[];
    before: string;
    after: string;
}

export interface ActivateRolePayload {
    operation: ActivateRolePayloadOperation;
}

export interface DeactivateRolePayload {
    operation: DeactivateRolePayloadOperation;
}

export interface UpdateRolePayload {
    operation: UpdateRolePayloadOperation;
    payload: Payload;
}

export interface Role {
    _id: string;
    name: string;
    description: string;
    isActive: any;
    permissions: string[];
}

export interface CreateRolePayload {
    name: string;
    description: string;
    permissions: string[];
}

export interface CheckEmailExistResult {
    emailExist: boolean;
}

export interface FindUsersResult {
    data: User[];
    before: string;
    after: string;
}

export interface FindAllUsersResult {
    data: User[];
}

export interface PermissionsResult {
    data: string[];
}

export interface FacebookLogin {
    uid: string;
    email: string;
    provider: FacebookLoginProvider;
}

export interface GoogleLogin {
    uid: string;
    email: string;
    provider: GoogleLoginProvider;
}

export interface PhoneLogin {
    phoneNo: string;
    provider: PhoneLoginProvider;
}

export interface EmailLogin {
    email: string;
    provider: EmailLoginProvider;
}

export interface User {
    _id: string;
    id: string;
    email: string;
    familyName: string;
    givenName: string;
    fullName: string;
    phoneNo: string;
    address: string;
    description: string;
    avatarUrl: string;
    dob: number;
    gender: string;
    loginDetail: any;
    roles: string[];
    completeSignUp: boolean;
    centreId: string;
    isActive: boolean;
    createdAt: number;
    createdBy: number;
}

export interface UpdateUserPayload {
    operation: UpdateUserPayloadOperation;
    payload: Payload2;
}

export interface ChangePasswordPayload {
    newPassword: string;
}

export interface UpdateProfilePayload {
    operation: UpdateProfilePayloadOperation;
    payload: Payload3;
}

export interface ActivateUserPayload {
    operation: ActivateUserPayloadOperation;
}

export interface DeactivateUserPayload {
    operation: DeactivateUserPayloadOperation;
}

export interface UpdateAvatarPayload {
    operation: UpdateAvatarPayloadOperation;
    data: Data;
}

export interface CreateUserPayload {
    email: string;
    password: string;
    roles: string[];
    familyName: string;
    givenName: string;
}

export interface CheckFilterNameResult {
    existedFilterName: boolean;
}

export interface CreateLeadFilterPayload {
    name: string;
    search: string;
    filters: LeadFilterItem[];
}

export interface LeadFilterItem {
    fieldName: string;
    operator: string;
    value: any;
}

export interface LeadFilter {
    _id: string;
    name: string;
    owner: any;
    search: string;
    filters: LeadFilterItem[];
    createdAt: number;
}

export interface FindLeadFiltersResult {
    data: LeadFilter[];
    before: string;
    after: string;
}

export interface FindListsResult {
    data: List[];
    before: string;
    after: string;
}

export interface UpdateListPayload {
    operation: UpdateListPayloadOperation;
    payload: Payload4;
}

export interface List {
    _id: string;
    id: string;
    name: string;
    description: string;
    isActive: any;
}

export interface CreateListPayload {
    name: string;
    description: string;
}

export interface SystemConfig {
    _id: string;
    id: string;
    option: string;
    description: string;
    value: any;
}

export interface FindSomeSystemConfigsResult {
    data: SystemConfig[];
}

export interface FindOneSystemConfigResult {
    data: SystemConfig;
}

export interface FindSystemConfigsResult {
    data: SystemConfig[];
    before: string;
    after: string;
}

export interface UpdateSystemConfigPayload {
    operation: UpdateSystemConfigPayloadOperation;
    payload: SystemConfig;
}

export interface CreateSystemConfigPayload {
    option: string;
    value: string;
}

export interface FindCampaignsResult {
    data: Campaign[];
    before: string;
    after: string;
}

export interface Campaign {
    _id: string;
    id: string;
    sourceId: string;
    name: string;
    order: number;
}

export interface UpdateCampaignPayload {
    operation: UpdateCampaignPayloadOperation;
    payload: Campaign;
}

export interface CreateCampaignPayload {
    sourceId: string;
    name: string;
    order: number;
}

export interface LeadTask {
    _id: string;
    id: string;
    leadId: string;
    assigneeId: string;
    title: string;
    dueAt: number;
    status: number;
    finishedAt: number;
}

export interface UpdateLeadTaskPayload {
    operation: UpdateLeadTaskPayloadOperation;
    payload: LeadTask;
}

export interface CreateLeadTaskPayload {
    leadId: string;
    assigneeId: string;
    title: string;
    dueAt: number;
    status: number;
    finishAt: number;
}

export interface FindAllLeadTasksResult {
    data: LeadTask[];
}

export interface ProspectingList {
    _id: string;
    id: string;
    name: string;
    source: string;
    entries: any;
    sourceName: string;
    assigneeId: string;
    autoAddProductOrder: boolean;
    comboId: string;
    comboName: string;
    courses: any[];
    createdAt: number;
}

export interface UpdateProspectingListPayload {
    operation: UpdateProspectingListPayloadOperation;
    payload: ProspectingList;
}

export interface CreateProspectingListPayload {
    name: string;
    source: string;
    entries: any;
    sourceName: string;
    assigneeId: string;
    autoAddProductOrder: boolean;
    comboId: string;
    comboName: string;
    courses: any[];
}

export interface FindAllProspectingListsResult {
    data: ProspectingList[];
    before: string;
    after: string;
}

export interface MappingContactInfo {
    key: string;
    refId: string;
}

export interface UpdateLeadAppointmentPayload {
    operation: UpdateLeadAppointmentPayloadOperation;
    payload: LeadAppointment;
}

export interface CreateLeadAppointmentPayload {
    leadId: string;
    assigneeId: string;
    title: string;
    dueAt: number;
    status: number;
    finishAt: number;
}

export interface FindAllLeadAppointmentsResult {
    data: LeadAppointment[];
    before: string;
    after: string;
}

export interface EmailTemplate {
    _id: string;
    id: string;
    name: string;
    text: string;
}

export interface EmailTemplateConfig {
    _id: string;
    id: string;
    eventName: string;
    template: string;
}

export interface FindEmailTemplatesResult {
    data: EmailTemplate[];
    before: string;
    after: string;
}

export interface FindEmailTemplateConfigsResult {
    data: EmailTemplateConfig[];
    before: string;
    after: string;
}

export interface FindEmailTemplateConfigByNameResult {
    data: EmailTemplateConfig;
}

export interface UpdateEmailTemplatePayload {
    operation: UpdateEmailTemplatePayloadOperation;
    payload: EmailTemplate;
}

export interface UpdateEmailTemplateConfigPayload {
    operation: UpdateEmailTemplateConfigPayloadOperation;
    payload: EmailTemplateConfig;
}

export interface CreateEmailTemplatePayload {
    name: string;
    payload: EmailTemplate;
}

export interface CreateEmailTemplateConfigPayload {
    eventName: string;
    template: string;
}

export interface DefaultTask {
    _id: string;
    id: string;
    name: string;
    schedule: string;
}

export interface FindDefaultTasksResult {
    data: DefaultTask[];
    before: string;
    after: string;
}

export interface UpdateDefaultTaskPayload {
    operation: UpdateDefaultTaskPayloadOperation;
    payload: DefaultTask;
}

export interface CreateDefaultTaskPayload {
    name: string;
    schedule: string;
}

export interface LeadConversation {
    _id: string;
    id: string;
    leadId: string;
    messageCount: number;
    contactId: string;
    ownerId: string;
    channel: number;
    fbChatId: string;
    fbChatLink: string;
}

export interface LeadPaymentTransaction {
    _id: string;
    leadId: string;
    paymentType: string;
    amount: number;
    note: string;
}

export interface FindLeadPaymentTransaction {
    data: LeadPaymentTransaction[];
}

export interface CreateLeadPaymentTransaction {
    leadId: string;
    paymentType: string;
    amount: number;
    note: string;
}

export interface UpdateLeadPaymentTransaction {
    _id: string;
    paymentType: string;
    amount: number;
    note: string;
}

export interface LeadNote {
    _id: string;
    leadId: string;
    content: string;
    createdAt: number;
    createdBy: User;
}

export interface FindLeadNote {
    data: LeadNote[];
}

export interface CreateLeadNote {
    leadId: string;
    content: string;
}

export interface UpdateLeadNote {
    _id: string;
    content: string;
}

export interface FindLeadConversationsResult {
    data: LeadConversation[];
    before: string;
    after: string;
}

export interface LeadNotification {
    _id: string;
    id: string;
    leadId: string;
    contactId: string;
    type: number;
    content: string;
    isSeen: boolean;
    isChecked: boolean;
    objectId: string;
    objectType: string;
    createdAt: number;
    createdBy: string;
}

export interface FindLeadNotificationsResult {
    data: LeadNotification[];
    before: string;
    after: string;
}

export interface UpdateLeadNotificationPayload {
    operation: UpdateLeadNotificationPayloadOperation;
    payload: LeadNotification;
}

export interface LeadAttachment {
    _id: string;
    id: string;
    leadId: string;
    type: number;
    title: string;
    url: number;
    otherUrl: string;
    createdBy: string;
}

export interface CreateLeadAttachmentPayload {
    leadId: string;
    otherLink: number;
    createdAt: number;
}

export interface FindLeadAttachmentsResult {
    data: LeadAttachment[];
    before: string;
    after: string;
}

export interface LeadMessageDetail {
    _id: string;
    id: string;
    conversationId: string;
    direction: number;
    content: string;
    html: string;
    createdAt: number;
    createdBy: string;
    channel: any;
    attachments: LeadAttachment[];
}

export interface SyncEmailMessage {
    leadId: string;
}

export interface FindLeadMessageDetailsResult {
    data: LeadMessageDetail[];
    before: string;
    after: string;
}

export interface FindClassesResult {
    data: Class[];
    before: string;
    after: string;
}

export interface FindAllClassesResult {
    data: Class[];
}

export interface UpdateClassPayload {
    operation: UpdateClassPayloadOperation;
    payload: Class;
}

export interface Class {
    _id: string;
    id: string;
    name: string;
    description: string;
    isActive: boolean;
    startDate: string;
    endDate: string;
    centreId: string;
}

export interface CreateClassPayload {
    name: string;
    description: string;
    startDate: string;
    endDate: string;
}

export interface ProductCombo {
    _id: string;
    name: string;
    field: string;
    condition: string;
    conditionValue: number;
    discountType: string;
    discountValue: number;
}

export interface FindProductComboResult {
    data: ProductCombo[];
    before: string;
    after: string;
}

export interface FindAllProductComboResult {
    data: ProductCombo[];
}

export interface CreateProductComboPayload {
    name: string;
    field: string;
    condition: string;
    discountType: string;
    discountValue: number;
}

export interface UpdateProductComboPayload {
    operation: UpdateProductComboPayloadOperation;
    payload: Payload5;
}

export interface ProductCourse {
    _id: string;
    name: string;
    shortName: string;
    order: number;
    tuitionBeforeDiscount: number;
    isAvailableInCombo: boolean;
}

export interface FindProductCourseResult {
    data: ProductCourse[];
    total: number;
}

export interface FindAllProductCourseResult {
    data: ProductCourse[];
}

export interface CreateProductCoursePayload {
    name: string;
    shortName: string;
    order: number;
    tuitionBeforeDiscount: number;
    isAvailableInCombo: boolean;
}

export interface UpdateProductCoursePayload {
    operation: UpdateProductCoursePayloadOperation;
    payload: Payload6;
}

export interface LeadProductOrder {
    _id: string;
    leadId: string;
    comboId: string;
    comboName: string;
    courses: Courses[];
}

export interface FindLeadProductOrderResult {
    data: LeadProductOrder[];
    total: number;
}

export interface CreateLeadProductOrderPayload {
    leadId: string;
    comboId: string;
    comboName: string;
    courses: Courses2[];
}

export interface UpdateLeadProductOrderPayload {
    operation: UpdateLeadProductOrderPayloadOperation;
    payload: Payload7;
}

export interface UpdateRootContactPayload {
    operation: string;
    payload: Payload8;
}

export interface FindCentresResult {
    data: Centre[];
    before: string;
    after: string;
}

export interface FindAllCentresResult {
    data: Centre[];
}

export interface UpdateCentrePayload {
    operation: UpdateCentrePayloadOperation;
    payload: Centre;
}

export interface Centre {
    _id: string;
    id: string;
    name: string;
    shortName: string;
    description: string;
    isActive: any;
}

export interface CreateCentrePayload {
    name: string;
    description: string;
}

export interface AddContactFamilyMemberPayload {
    operation: AddContactFamilyMemberPayloadOperation;
    payload: Payload9;
}

export interface UpdateContactDetailPayload {
    operation: UpdateContactDetailPayloadOperation;
    payload: Payload10;
}

export interface FindContactsResult {
    data: Contact[];
    count: number;
}

export interface CreateContactPayload {
    contactBasicInfo: ContactBasicInfo;
}

export interface FamilyMember {
    _id: string;
    fullName: string;
    phoneNumber: string;
    email: string;
    relation: FamilyMemberRelation;
}

export interface Contact {
    _id: string;
    fullName: string;
    phoneNumber: string;
    gender: ContactGender;
    email: string;
    address: string;
    dob: string;
    facebook: string;
    zalo: string;
    school: string;
    family: FamilyMember[];
}

export interface ContactSummary {
    total: number;
    active: number;
}

export interface ProductEnrollmentItem {
    course: LmsCourse;
    class: LmsClass;
    status: ProductEnrollmentItemStatus;
    cancelled: boolean;
    lmsOperationExecutive: any;
}

export interface UpdateProductEnrollmentItemPayload {
    course: string;
    class: string;
}

export interface Promotion {
    promotionType: PromotionType;
    discountType: PromotionDiscountType;
    percent: number;
    value: number;
}

export interface UpdateLeadOrderItem {
    candidate: string;
    product: string;
    promotion: Promotion;
}

export interface CreateLeadOrderPayload {
    orderItems: UpdateLeadOrderItem[];
}

export interface LeadProduct {
    candidate: Contact;
    product: Product;
}

export interface UpdateLeadDetailPayload {
    operation: UpdateLeadDetailPayloadOperation;
    payload: Payload11;
}

export interface UpdateLeadOwnerPayload {
    operation: UpdateLeadOwnerPayloadOperation;
    payload: Payload12;
}

export interface MakeFamilyMemberCustomerPayload {
    operation: MakeFamilyMemberCustomerPayloadOperation;
}

export interface LeadAppointment {
    _id: string;
    id: string;
    leadId: string;
    assigneeId: string;
    dueAt: number;
    status: number;
    finishedAt: any;
    title: string;
    time: string;
    centreId: string;
    currentStatus: LeadAppointmentCurrentStatus;
    createdAt: number;
    createdBy: User;
}

export interface UpdateLeadProductsItem {
    candidate: string;
    product: string;
}

export interface UpdateLeadProductsPayload {
    products: UpdateLeadProductsItem[];
}

export interface UpdateLeadCustomerPayload {
    fullName: string;
    gender: UpdateLeadCustomerPayloadGender;
    email: string;
    address: string;
    dob: string;
    facebook: string;
    zalo: string;
    school: string;
}

export interface UpdateLeadFamilyMemberPayload {
    fullName: string;
    phoneNumber: string;
    gender: UpdateLeadFamilyMemberPayloadGender;
    email: string;
    address: string;
    dob: string;
    facebook: string;
    zalo: string;
    school: string;
    relation: UpdateLeadFamilyMemberPayloadRelation;
}

export interface PatchResponse {
    data: any[];
}

export interface LeadMessage {
    messageType: LeadMessageMessageType;
    success: boolean;
    errorMessage: string;
    emailInfo: EmailInfo;
    smsInfo: any;
    facebookMessageInfo: any;
}

export interface SendEmailPayload {
    operation: SendEmailPayloadOperation;
    payload: Payload13;
}

export interface LeadAppointmentPayload {
    title: string;
    time: string;
    centreId: string;
    currentStatus: LeadAppointmentPayloadCurrentStatus;
}

export interface LeadNotePayload {
    content: string;
}

export interface LeadReminder {
    _id: string;
    title: string;
    dueAt: string;
    finishedAt: string;
    status: LeadReminderStatus;
    createdAt: number;
    createdBy: User;
}

export interface LeadReminderPayload {
    title: string;
    dueAt: string;
}

export interface LeadReminderUpdatePayload {
    status: LeadReminderUpdatePayloadStatus;
}

export interface LeadOrderProductItemPayload {
    /** _id of candidate */
    candidate: string;
    /** _id of product */
    product: string;
    promotion: Promotion;
}

export interface Lead {
    _id: string;
    id: string;
    centre: Centre2;
    sourceId: string;
    campaignId: string;
    owner: Owner;
    contact: Contact2;
    customer: Customer;
    productOrder: ProductOrder;
    tuition: Tuition;
    lastContactedAt: string;
    currentStage: string;
    currentStatus: string;
    v2Status: LeadV2Status;
    lastUpdatedStageAt: string;
    overdueStatusAt: string;
    paymentDueAt: string;
    recentTaskDueAt: string;
    recentAppointmentDueAt: string;
    messages: LeadMessage[];
    reminders: LeadReminder[];
    notes: LeadNote[];
    appointments: LeadAppointment[];
    products: LeadProduct[];
    order: Order;
    payments: LeadPaymentItem[];
    refunds: LeadRefundItem[];
}

export interface LeadOrderItem {
    candidate: Contact;
    product: Product;
    promotion: Promotion;
    enrollments: ProductEnrollmentItem[];
}

export interface LeadPaymentItem {
    amount: number;
    payday: string;
    note: string;
}

export interface LeadRefundItem {
    amount: number;
    payday: string;
    note: string;
}

export interface CreateLeadPayload {
    overwrite: boolean;
    contactId: string;
    contactInfo: ContactInfo;
    leadInfo: LeadInfo;
}

export interface FindLeadsResult {
    data: Lead[];
    before: string;
    after: string;
    count: number;
}

export interface UpdateLeadStatusPayload {
    operation: UpdateLeadStatusPayloadOperation;
    payload: Payload14;
}

export interface FindLmsCategoryResult {
    data: LmsCategory[];
    count: number;
}

export interface LmsCategory {
    _id: string;
    title: string;
    descripttion: string;
}

export interface FindLmsClassResult {
    data: LmsClass[];
    count: number;
}

export interface LmsClass {
    _id: string;
    title: string;
    status: string;
    startTime: string;
    endTime: string;
    descripttion: string;
}

export interface FindLmsCourseResult {
    data: LmsCourse[];
    count: number;
}

export interface LmsCourse {
    _id: string;
    title: string;
    descripttion: string;
}

export interface UpdateProductPayload {
    operation: UpdateProductPayloadOperation;
    payload: Payload15;
}

export interface CreateProductPayload {
    name: string;
    code: string;
    price: number;
    category: CreateProductPayloadCategory;
    productLine: CreateProductPayloadProductLine;
    type: CreateProductPayloadType;
    course: string;
    maxCourses: number;
    maxDuration: number;
    selectableCourses: string[];
    isActive: boolean;
}

export interface FindProductsResult {
    data: Product[];
    count: number;
}

export interface DeactivateProductPayload {
    operation: DeactivateProductPayloadOperation;
    payload: any;
}

export interface ActivateProductPayload {
    operation: ActivateProductPayloadOperation;
    payload: any;
}

export interface Product {
    _id: string;
    name: string;
    code: string;
    price: number;
    category: ProductCategory;
    productLine: ProductLine;
    type: ProductType;
    single: Single;
    combo: Combo;
    special: Special;
    isActive: boolean;
    createdAt: number;
    createdBy: User;
}

export enum TuitionPaidPercent {
    _0 = "0",
    _0100 = "0:100",
    _100 = "100",
}

export enum LmsEnrollmentStatus {
    Not_Enrolled = "Not Enrolled",
    Waiting = "Waiting",
    Approved = "Approved",
    Rejected = "Rejected",
}

export enum ActivateRolePayloadOperation {
    Activate = "activate",
}

export enum DeactivateRolePayloadOperation {
    Deactivate = "deactivate",
}

export enum UpdateRolePayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload {
    name: string;
    description: string;
    permissions: string[];
}

export enum FacebookLoginProvider {
    Facebook = "facebook",
}

export enum GoogleLoginProvider {
    Google = "google",
}

export enum PhoneLoginProvider {
    Phone = "phone",
}

export enum EmailLoginProvider {
    Email = "email",
}

export enum UpdateUserPayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload2 {
    roles: string[];
    familyName: string;
    givenName: string;
    email: string;
}

export enum UpdateProfilePayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload3 {
    familyName: string;
    givenName: string;
    phoneNo: string;
    email: string;
    address: string;
    description: string;
}

export enum ActivateUserPayloadOperation {
    Activate = "activate",
}

export enum DeactivateUserPayloadOperation {
    Deactivate = "deactivate",
}

export enum UpdateAvatarPayloadOperation {
    UpdateAvatar = "updateAvatar",
}

export interface Data {
    avatarUrl: string;
}

export enum UpdateListPayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload4 {
    name: string;
    description: string;
}

export enum UpdateSystemConfigPayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateCampaignPayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateLeadTaskPayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateProspectingListPayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateLeadAppointmentPayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateEmailTemplatePayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateEmailTemplateConfigPayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateDefaultTaskPayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateLeadNotificationPayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateClassPayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum UpdateProductComboPayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload5 {
    _id: string;
    name: string;
    field: string;
    condition: string;
    discountType: string;
    discountValue: number;
}

export enum UpdateProductCoursePayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload6 {
    _id: string;
    name: string;
    shortName: string;
    order: number;
    tuitionBeforeDiscount: number;
    isAvailableInCombo: boolean;
}

export interface Courses {
    _id: string;
    name: string;
    shortName: string;
    tuitionBeforeDiscount: number;
    discountType: string;
    discountValue: number;
    stage: string;
    status: string;
    class: string;
}

export interface Courses2 {
    _id: string;
    name: string;
    shortName: string;
    tuitionBeforeDiscount: number;
    discountType: string;
    discountValue: number;
    stage: string;
    status: string;
    class: string;
}

export enum UpdateLeadProductOrderPayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload7 {
    _id: string;
    leadId: string;
    comboId: string;
    comboName: string;
    courses: Courses3[];
}

export interface Payload8 {
    lmsStudentId: string;
}

export enum UpdateCentrePayloadOperation {
    UpdateDetail = "updateDetail",
}

export enum AddContactFamilyMemberPayloadOperation {
    AddFamilyMember = "addFamilyMember",
}

export interface Payload9 {
    contactId: string;
    contactInfo: ContactInfo2;
    relation: Payload9Relation;
}

export enum UpdateContactDetailPayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload10 {
    fullName: string;
    gender: Payload10Gender;
    email: string;
    address: string;
    dob: string;
    facebook: string;
    zalo: string;
    school: string;
}

export interface ContactBasicInfo {
    fullName: string;
    phoneNumber: string;
    gender: ContactBasicInfoGender;
    email: string;
    address: string;
    dob: string;
    facebook: string;
    zalo: string;
    school: string;
}

export enum FamilyMemberRelation {
    SON = "SON",
    DAUGHTER = "DAUGHTER",
    GRAND_SON = "GRAND_SON",
    GRAND_DAUGHTER = "GRAND_DAUGHTER",
    NEPHEW = "NEPHEW",
    OTHER = "OTHER",
}

export enum ContactGender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
}

export enum ProductEnrollmentItemStatus {
    Not_Enrolled = "Not Enrolled",
    Waiting = "Waiting",
    Approved = "Approved",
    Rejected = "Rejected",
}

export enum PromotionType {
    SalesmanInput = "SalesmanInput",
    SelectFromConfig = "SelectFromConfig",
}

export enum PromotionDiscountType {
    Value = "Value",
    Percent = "Percent",
}

export enum UpdateLeadDetailPayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload11 {
    channel: Payload11Channel;
    source: Payload11Source;
    campaign: Payload11Campaign;
    medium: string;
    content: string;
}

export enum UpdateLeadOwnerPayloadOperation {
    UpdateOwner = "updateOwner",
}

export interface Payload12 {
    ids: string[];
    newOwnerId: string;
}

export enum MakeFamilyMemberCustomerPayloadOperation {
    MakeFamilyMemberCustomer = "makeFamilyMemberCustomer",
}

export enum LeadAppointmentCurrentStatus {
    WAITING = "WAITING",
    FAILED = "FAILED",
    PASS = "PASS",
    CANCEL = "CANCEL",
}

export enum UpdateLeadCustomerPayloadGender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
}

export enum UpdateLeadFamilyMemberPayloadGender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
}

export enum UpdateLeadFamilyMemberPayloadRelation {
    SON = "SON",
    DAUGHTER = "DAUGHTER",
    GRAND_SON = "GRAND_SON",
    GRAND_DAUGHTER = "GRAND_DAUGHTER",
    NEPHEW = "NEPHEW",
    OTHER = "OTHER",
}

export enum LeadMessageMessageType {
    EMAIL = "EMAIL",
    FACEBOOK_MESSAGE = "FACEBOOK_MESSAGE",
    SMS = "SMS",
}

export interface EmailInfo {
    attachments: string[];
    subject: string;
    html: string;
    bcc: string;
}

export enum SendEmailPayloadOperation {
    SendEmail = "sendEmail",
}

export interface Payload13 {
    attachments: string[];
    subject: string;
    html: string;
    bcc: string;
    leads: string[];
}

export enum LeadAppointmentPayloadCurrentStatus {
    WAITING = "WAITING",
    FAILED = "FAILED",
    PASS = "PASS",
    CANCEL = "CANCEL",
}

export enum LeadReminderStatus {
    Active = "Active",
    Completed = "Completed",
    Canceled = "Canceled",
}

export enum LeadReminderUpdatePayloadStatus {
    Active = "Active",
    Completed = "Completed",
    Canceled = "Canceled",
}

export interface Centre2 {
    _id: string;
    name: string;
    shortName: string;
}

export interface Owner {
    id: string;
    firstName: string;
    lastName: string;
    avatar: string;
}

export interface Contact2 {
    _id: string;
    firstName: string;
    lastName: string;
    phone: string;
    email: string;
    fb: string;
    address: string;
    userType: string;
}

export interface Customer {
    _id: Contact;
    fullName: string;
    phoneNumber: string;
    email: string;
    family: FamilyMember[];
}

export interface ProductOrder {
    _id: string;
    comboName: string;
    courses: any[];
}

export interface Tuition {
    totalAfterDiscount: number;
    remaining: number;
    completePercent: number;
}

export enum LeadV2Status {
    L0A = "L0A",
    L0B = "L0B",
    L1A = "L1A",
    L1B = "L1B",
    L1C = "L1C",
    L2A = "L2A",
    L2B = "L2B",
    L2C = "L2C",
    L2D = "L2D",
    L2E = "L2E",
    L2F = "L2F",
    L2G = "L2G",
    L2X = "L2X",
    L3A = "L3A",
    L3B = "L3B",
    L3C = "L3C",
    L4A = "L4A",
    L4B = "L4B",
    L5A = "L5A",
    L5B = "L5B",
    L5C = "L5C",
}

export interface Order {
    code: number;
    productItems: LeadOrderItem[];
    isCancelled: boolean;
}

export interface ContactInfo {
    fullName: string;
    phoneNumber: string;
    gender: ContactInfoGender;
    email: string;
    address: string;
    dob: string;
    facebook: string;
    zalo: string;
    school: string;
}

export interface LeadInfo {
    status: LeadInfoStatus;
    channel: LeadInfoChannel;
    source: LeadInfoSource;
    campaign: LeadInfoCampaign;
    medium: LeadInfoMedium;
    content: Campaign;
}

export enum UpdateLeadStatusPayloadOperation {
    UpdateStatus = "updateStatus",
}

export interface Payload14 {
    statusName: string;
}

export enum UpdateProductPayloadOperation {
    UpdateDetail = "updateDetail",
}

export interface Payload15 {
    type: string;
    price: number;
    isActive: boolean;
    selectableCourses: string[];
}

export enum CreateProductPayloadCategory {
    Teens = "Teens",
    Kids = "Kids",
    _18 = "18",
}

export enum CreateProductPayloadProductLine {
    Game = "Game",
    Web = "Web",
    Other = "Other",
    C4E = "C4E",
    App = "App",
    Data = "Data",
}

export enum CreateProductPayloadType {
    Single = "Single",
    Combo = "Combo",
    Special = "Special",
}

export enum DeactivateProductPayloadOperation {
    Deactivate = "deactivate",
}

export enum ActivateProductPayloadOperation {
    Activate = "activate",
}

export enum ProductCategory {
    Teens = "Teens",
    Kids = "Kids",
    _18 = "18",
}

export enum ProductLine {
    Game = "Game",
    Web = "Web",
    Other = "Other",
    C4E = "C4E",
    App = "App",
    Data = "Data",
}

export enum ProductType {
    Single = "Single",
    Combo = "Combo",
    Special = "Special",
}

export interface Single {
    course: LmsCourse;
}

export interface Combo {
    maxCourses: number;
    selectableCourses: LmsCourse[];
}

export interface Special {
    maxDuration: number;
    selectableCourses: LmsCourse[];
}

export interface Courses3 {
    _id: string;
    name: string;
    shortName: string;
    tuitionBeforeDiscount: number;
    discountType: string;
    discountValue: number;
    stage: string;
    status: string;
    class: string;
}

export interface ContactInfo2 {
    fullName: string;
    phoneNumber: string;
    gender: ContactInfo2Gender;
    email: string;
    address: string;
    dob: string;
    facebook: string;
    zalo: string;
    school: string;
}

export enum Payload9Relation {
    SON = "SON",
    DAUGHTER = "DAUGHTER",
    GRAND_SON = "GRAND_SON",
    GRAND_DAUGHTER = "GRAND_DAUGHTER",
    NEPHEW = "NEPHEW",
    OTHER = "OTHER",
}

export enum Payload10Gender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
}

export enum ContactBasicInfoGender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
}

export enum Payload11Channel {
    Website = "Website",
    Fanpage = "Fanpage",
    Social = "Social",
    Referral = "Referral",
    Native = "Native",
    Email = "Email",
    Event_offline = "Event offline",
    Other = "Other",
    Self_created = "Self created",
    Database = "Database",
}

export enum Payload11Source {
    None = "None",
    Organic = "Organic",
    Direct = "Direct",
    Ads = "Ads",
    Zalo = "Zalo",
    Instagram = "Instagram",
    Youtube = "Youtube",
    Coccoc = "Coccoc",
    Site = "Site",
    Email_marketing = "Email marketing",
    Email_ads = "Email ads",
    Hotline = "Hotline",
    Referral = "Referral",
    Direct_sale = "Direct sale",
    Resales = "Resales",
    Telemarketing = "Telemarketing",
    Event_offline = "Event offline",
}

export enum Payload11Campaign {
    None = "None",
    Search = "Search",
    Display = "Display",
    Inbox = "Inbox",
    Comment = "Comment",
    Conversion = "Conversion",
    Lead = "Lead",
    Mess = "Mess",
    Post_engage = "Post engage",
    Instream = "Instream",
    Outstream = "Outstream",
    Bumper6 = "Bumper6",
    Bumper15 = "Bumper15",
    Browserskin = "Browserskin",
    Newtab = "Newtab",
    Ads = "Ads",
    PR = "PR",
    HV_giới_thiệu = "HV giới thiệu",
    PH_giới_thiệu = "PH giới thiệu",
    Sale_s_contact = "Sale's contact",
}

export enum ContactInfoGender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
}

export enum LeadInfoStatus {
    L0A = "L0A",
    L0B = "L0B",
    L1A = "L1A",
    L1B = "L1B",
    L1C = "L1C",
    L2A = "L2A",
    L2B = "L2B",
    L2C = "L2C",
    L2D = "L2D",
    L2E = "L2E",
    L2F = "L2F",
    L2G = "L2G",
    L2X = "L2X",
    L3A = "L3A",
    L3B = "L3B",
    L3C = "L3C",
    L4A = "L4A",
    L4B = "L4B",
    L5A = "L5A",
    L5B = "L5B",
    L5C = "L5C",
}

export enum LeadInfoChannel {
    Website = "Website",
    Fanpage = "Fanpage",
    Social = "Social",
    Referral = "Referral",
    Native = "Native",
    Email = "Email",
    Event_offline = "Event offline",
    Other = "Other",
    Self_created = "Self created",
    Database = "Database",
}

export enum LeadInfoSource {
    None = "None",
    Organic = "Organic",
    Direct = "Direct",
    Ads = "Ads",
    Zalo = "Zalo",
    Instagram = "Instagram",
    Youtube = "Youtube",
    Coccoc = "Coccoc",
    Site = "Site",
    Email_marketing = "Email marketing",
    Email_ads = "Email ads",
    Hotline = "Hotline",
    Referral = "Referral",
    Direct_sale = "Direct sale",
    Resales = "Resales",
    Telemarketing = "Telemarketing",
    Event_offline = "Event offline",
}

export enum LeadInfoCampaign {
    None = "None",
    Search = "Search",
    Display = "Display",
    Inbox = "Inbox",
    Comment = "Comment",
    Conversion = "Conversion",
    Lead = "Lead",
    Mess = "Mess",
    Post_engage = "Post engage",
    Instream = "Instream",
    Outstream = "Outstream",
    Bumper6 = "Bumper6",
    Bumper15 = "Bumper15",
    Browserskin = "Browserskin",
    Newtab = "Newtab",
    Ads = "Ads",
    PR = "PR",
    HV_giới_thiệu = "HV giới thiệu",
    PH_giới_thiệu = "PH giới thiệu",
    Sale_s_contact = "Sale's contact",
}

export enum LeadInfoMedium {
    Keyword = "Keyword",
    None = "None",
    Banner = "Banner",
    Landing = "Landing",
    Form = "Form",
    Chat = "Chat",
    Video = "Video",
    Cpm = "Cpm",
    Cpc = "Cpc",
    Cpd = "Cpd",
    Funnel = "Funnel",
    Cold_data = "Cold data",
}

export enum ContactInfo2Gender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}